{"ast":null,"code":"function map(value, iStart, iStop, oStart, oStop) {\n  return oStart + (oStop - oStart) * ((value - iStart) / (iStop - iStart));\n}\nfunction isNumber(subject) {\n  return typeof subject === 'number';\n}\nfunction isObject(subject) {\n  return Object.prototype.toString.call(subject) === '[object Object]';\n}\nfunction isArray(subject) {\n  return Array.isArray(subject);\n}\nfunction isRecord(subject) {\n  return isObject(subject) || isArray(subject);\n}\nfunction mathAbs(n) {\n  return Math.abs(n);\n}\nfunction mathSign(n) {\n  return !n ? 0 : n / mathAbs(n);\n}\nfunction deltaAbs(valueB, valueA) {\n  return mathAbs(valueB - valueA);\n}\nfunction factorAbs(valueB, valueA) {\n  if (valueB === 0 || valueA === 0) return 0;\n  if (mathAbs(valueB) <= mathAbs(valueA)) return 0;\n  var diff = deltaAbs(mathAbs(valueB), mathAbs(valueA));\n  return mathAbs(diff / valueB);\n}\nfunction roundToDecimals(decimalPoints) {\n  var pow = Math.pow(10, decimalPoints);\n  return function (n) {\n    return Math.round(n * pow) / pow;\n  };\n}\nfunction arrayKeys(array) {\n  return objectKeys(array).map(Number);\n}\nfunction arrayLast(array) {\n  return array[arrayLastIndex(array)];\n}\nfunction arrayLastIndex(array) {\n  return Math.max(0, array.length - 1);\n}\nfunction objectKeys(object) {\n  return Object.keys(object);\n}\nfunction objectsMergeDeep(objectA, objectB) {\n  return [objectA, objectB].reduce(function (mergedObjects, currentObject) {\n    objectKeys(currentObject).forEach(function (key) {\n      var valueA = mergedObjects[key];\n      var valueB = currentObject[key];\n      var areObjects = isObject(valueA) && isObject(valueB);\n      mergedObjects[key] = areObjects ? objectsMergeDeep(valueA, valueB) : valueB;\n    });\n    return mergedObjects;\n  }, {});\n}\nfunction objectsAreEqual(objectA, objectB) {\n  var objectAKeys = objectKeys(objectA);\n  var objectBKeys = objectKeys(objectB);\n  if (objectAKeys.length !== objectBKeys.length) return false;\n  return objectAKeys.every(function (key) {\n    var valueA = objectA[key];\n    var valueB = objectB[key];\n    if (typeof valueA === 'function') return \"\".concat(valueA) === \"\".concat(valueB);\n    if (!isRecord(valueA) || !isRecord(valueB)) return valueA === valueB;\n    return objectsAreEqual(valueA, valueB);\n  });\n}\nfunction Alignment(align, viewSize) {\n  var predefined = {\n    start: start,\n    center: center,\n    end: end\n  };\n  function start() {\n    return 0;\n  }\n  function center(n) {\n    return end(n) / 2;\n  }\n  function end(n) {\n    return viewSize - n;\n  }\n  function percent() {\n    return viewSize * Number(align);\n  }\n  function measure(n) {\n    if (isNumber(align)) return percent();\n    return predefined[align](n);\n  }\n  var self = {\n    measure: measure\n  };\n  return self;\n}\nfunction Animation(callback) {\n  var animationFrame = 0;\n  function ifAnimating(active, cb) {\n    return function () {\n      if (active === !!animationFrame) cb();\n    };\n  }\n  function start() {\n    animationFrame = window.requestAnimationFrame(callback);\n  }\n  function stop() {\n    window.cancelAnimationFrame(animationFrame);\n    animationFrame = 0;\n  }\n  var self = {\n    proceed: ifAnimating(true, start),\n    start: ifAnimating(false, start),\n    stop: ifAnimating(true, stop)\n  };\n  return self;\n}\nfunction Axis(axis, direction) {\n  var scroll = axis === 'y' ? 'y' : 'x';\n  var cross = axis === 'y' ? 'x' : 'y';\n  var startEdge = getStartEdge();\n  var endEdge = getEndEdge();\n  function measureSize(rect) {\n    var width = rect.width,\n      height = rect.height;\n    return scroll === 'x' ? width : height;\n  }\n  function getStartEdge() {\n    if (scroll === 'y') return 'top';\n    return direction === 'rtl' ? 'right' : 'left';\n  }\n  function getEndEdge() {\n    if (scroll === 'y') return 'bottom';\n    return direction === 'rtl' ? 'left' : 'right';\n  }\n  var self = {\n    scroll: scroll,\n    cross: cross,\n    startEdge: startEdge,\n    endEdge: endEdge,\n    measureSize: measureSize\n  };\n  return self;\n}\nfunction Limit(min, max) {\n  var length = mathAbs(min - max);\n  function reachedMin(n) {\n    return n < min;\n  }\n  function reachedMax(n) {\n    return n > max;\n  }\n  function reachedAny(n) {\n    return reachedMin(n) || reachedMax(n);\n  }\n  function constrain(n) {\n    if (!reachedAny(n)) return n;\n    return reachedMin(n) ? min : max;\n  }\n  function removeOffset(n) {\n    if (!length) return n;\n    return n - length * Math.ceil((n - max) / length);\n  }\n  var self = {\n    length: length,\n    max: max,\n    min: min,\n    constrain: constrain,\n    reachedAny: reachedAny,\n    reachedMax: reachedMax,\n    reachedMin: reachedMin,\n    removeOffset: removeOffset\n  };\n  return self;\n}\nfunction Counter(max, start, loop) {\n  var _a = Limit(0, max),\n    min = _a.min,\n    constrain = _a.constrain;\n  var loopEnd = max + 1;\n  var counter = withinLimit(start);\n  function withinLimit(n) {\n    return !loop ? constrain(n) : mathAbs((loopEnd + n) % loopEnd);\n  }\n  function get() {\n    return counter;\n  }\n  function set(n) {\n    counter = withinLimit(n);\n    return self;\n  }\n  function add(n) {\n    return set(get() + n);\n  }\n  function clone() {\n    return Counter(max, get(), loop);\n  }\n  var self = {\n    add: add,\n    clone: clone,\n    get: get,\n    set: set,\n    min: min,\n    max: max\n  };\n  return self;\n}\nfunction Direction(direction) {\n  var sign = direction === 'rtl' ? -1 : 1;\n  function apply(n) {\n    return n * sign;\n  }\n  var self = {\n    apply: apply\n  };\n  return self;\n}\nfunction EventStore() {\n  var listeners = [];\n  function add(node, type, handler, options) {\n    if (options === void 0) {\n      options = false;\n    }\n    node.addEventListener(type, handler, options);\n    listeners.push(function () {\n      return node.removeEventListener(type, handler, options);\n    });\n    return self;\n  }\n  function removeAll() {\n    listeners = listeners.filter(function (remove) {\n      return remove();\n    });\n    return self;\n  }\n  var self = {\n    add: add,\n    removeAll: removeAll\n  };\n  return self;\n}\nfunction Vector1D(value) {\n  var vector = value;\n  function get() {\n    return vector;\n  }\n  function set(n) {\n    vector = readNumber(n);\n    return self;\n  }\n  function add(n) {\n    vector += readNumber(n);\n    return self;\n  }\n  function subtract(n) {\n    vector -= readNumber(n);\n    return self;\n  }\n  function multiply(n) {\n    vector *= n;\n    return self;\n  }\n  function divide(n) {\n    vector /= n;\n    return self;\n  }\n  function normalize() {\n    if (vector !== 0) divide(vector);\n    return self;\n  }\n  function readNumber(n) {\n    return isNumber(n) ? n : n.get();\n  }\n  var self = {\n    add: add,\n    divide: divide,\n    get: get,\n    multiply: multiply,\n    normalize: normalize,\n    set: set,\n    subtract: subtract\n  };\n  return self;\n}\nfunction DragHandler(axis, direction, rootNode, target, dragTracker, location, animation, scrollTo, scrollBody, scrollTarget, index, eventHandler, percentOfView, loop, dragFree, skipSnaps) {\n  var crossAxis = axis.cross;\n  var focusNodes = ['INPUT', 'SELECT', 'TEXTAREA'];\n  var dragStartPoint = Vector1D(0);\n  var activationEvents = EventStore();\n  var interactionEvents = EventStore();\n  var dragThreshold = percentOfView.measure(20);\n  var snapForceBoost = {\n    mouse: 300,\n    touch: 400\n  };\n  var freeForceBoost = {\n    mouse: 500,\n    touch: 600\n  };\n  var baseSpeed = dragFree ? 5 : 16;\n  var baseMass = 1;\n  var startScroll = 0;\n  var startCross = 0;\n  var pointerIsDown = false;\n  var preventScroll = false;\n  var preventClick = false;\n  var isMouse = false;\n  function addActivationEvents() {\n    var node = rootNode;\n    activationEvents.add(node, 'touchmove', function () {\n      return undefined;\n    }).add(node, 'touchend', function () {\n      return undefined;\n    }).add(node, 'touchstart', down).add(node, 'mousedown', down).add(node, 'touchcancel', up).add(node, 'contextmenu', up).add(node, 'click', click);\n  }\n  function addInteractionEvents() {\n    var node = !isMouse ? rootNode : document;\n    interactionEvents.add(node, 'touchmove', move).add(node, 'touchend', up).add(node, 'mousemove', move).add(node, 'mouseup', up);\n  }\n  function removeAllEvents() {\n    activationEvents.removeAll();\n    interactionEvents.removeAll();\n  }\n  function isFocusNode(node) {\n    var name = node.nodeName || '';\n    return focusNodes.indexOf(name) > -1;\n  }\n  function forceBoost() {\n    var boost = dragFree ? freeForceBoost : snapForceBoost;\n    var type = isMouse ? 'mouse' : 'touch';\n    return boost[type];\n  }\n  function allowedForce(force, targetChanged) {\n    var next = index.clone().add(mathSign(force) * -1);\n    var isEdge = next.get() === index.min || next.get() === index.max;\n    var baseForce = scrollTarget.byDistance(force, !dragFree).distance;\n    if (dragFree || mathAbs(force) < dragThreshold) return baseForce;\n    if (!loop && isEdge) return baseForce * 0.4;\n    if (skipSnaps && targetChanged) return baseForce * 0.5;\n    return scrollTarget.byIndex(next.get(), 0).distance;\n  }\n  function down(evt) {\n    isMouse = evt.type === 'mousedown';\n    if (isMouse && evt.button !== 0) return;\n    var isMoving = deltaAbs(target.get(), location.get()) >= 2;\n    var clearPreventClick = isMouse || !isMoving;\n    var isNotFocusNode = !isFocusNode(evt.target);\n    var preventDefault = isMoving || isMouse && isNotFocusNode;\n    pointerIsDown = true;\n    dragTracker.pointerDown(evt);\n    dragStartPoint.set(target);\n    target.set(location);\n    scrollBody.useBaseMass().useSpeed(80);\n    addInteractionEvents();\n    startScroll = dragTracker.readPoint(evt);\n    startCross = dragTracker.readPoint(evt, crossAxis);\n    eventHandler.emit('pointerDown');\n    if (clearPreventClick) preventClick = false;\n    if (preventDefault) evt.preventDefault();\n  }\n  function move(evt) {\n    if (!preventScroll && !isMouse) {\n      if (!evt.cancelable) return up(evt);\n      var lastScroll = dragTracker.readPoint(evt);\n      var lastCross = dragTracker.readPoint(evt, crossAxis);\n      var diffScroll = deltaAbs(lastScroll, startScroll);\n      var diffCross = deltaAbs(lastCross, startCross);\n      preventScroll = diffScroll > diffCross;\n      if (!preventScroll && !preventClick) return up(evt);\n    }\n    var diff = dragTracker.pointerMove(evt);\n    if (!preventClick && diff) preventClick = true;\n    animation.start();\n    target.add(direction.apply(diff));\n    evt.preventDefault();\n  }\n  function up(evt) {\n    var currentLocation = scrollTarget.byDistance(0, false);\n    var targetChanged = currentLocation.index !== index.get();\n    var rawForce = dragTracker.pointerUp(evt) * forceBoost();\n    var force = allowedForce(direction.apply(rawForce), targetChanged);\n    var forceFactor = factorAbs(rawForce, force);\n    var isMoving = deltaAbs(target.get(), dragStartPoint.get()) >= 0.5;\n    var isVigorous = targetChanged && forceFactor > 0.75;\n    var isBelowThreshold = mathAbs(rawForce) < dragThreshold;\n    var speed = isVigorous ? 10 : baseSpeed;\n    var mass = isVigorous ? baseMass + 2.5 * forceFactor : baseMass;\n    if (isMoving && !isMouse) preventClick = true;\n    preventScroll = false;\n    pointerIsDown = false;\n    interactionEvents.removeAll();\n    scrollBody.useSpeed(isBelowThreshold ? 9 : speed).useMass(mass);\n    scrollTo.distance(force, !dragFree);\n    isMouse = false;\n    eventHandler.emit('pointerUp');\n  }\n  function click(evt) {\n    if (preventClick) evt.preventDefault();\n  }\n  function clickAllowed() {\n    return !preventClick;\n  }\n  function pointerDown() {\n    return pointerIsDown;\n  }\n  var self = {\n    addActivationEvents: addActivationEvents,\n    clickAllowed: clickAllowed,\n    pointerDown: pointerDown,\n    removeAllEvents: removeAllEvents\n  };\n  return self;\n}\nfunction DragTracker(axis) {\n  var logInterval = 170;\n  var startEvent;\n  var lastEvent;\n  function isTouchEvent(evt) {\n    return typeof TouchEvent !== 'undefined' && evt instanceof TouchEvent;\n  }\n  function readTime(evt) {\n    return evt.timeStamp;\n  }\n  function readPoint(evt, evtAxis) {\n    var property = evtAxis || axis.scroll;\n    var coord = \"client\".concat(property === 'x' ? 'X' : 'Y');\n    return (isTouchEvent(evt) ? evt.touches[0] : evt)[coord];\n  }\n  function pointerDown(evt) {\n    startEvent = evt;\n    lastEvent = evt;\n    return readPoint(evt);\n  }\n  function pointerMove(evt) {\n    var diff = readPoint(evt) - readPoint(lastEvent);\n    var expired = readTime(evt) - readTime(startEvent) > logInterval;\n    lastEvent = evt;\n    if (expired) startEvent = evt;\n    return diff;\n  }\n  function pointerUp(evt) {\n    if (!startEvent || !lastEvent) return 0;\n    var diffDrag = readPoint(lastEvent) - readPoint(startEvent);\n    var diffTime = readTime(evt) - readTime(startEvent);\n    var expired = readTime(evt) - readTime(lastEvent) > logInterval;\n    var force = diffDrag / diffTime;\n    var isFlick = diffTime && !expired && mathAbs(force) > 0.1;\n    return isFlick ? force : 0;\n  }\n  var self = {\n    isTouchEvent: isTouchEvent,\n    pointerDown: pointerDown,\n    pointerMove: pointerMove,\n    pointerUp: pointerUp,\n    readPoint: readPoint\n  };\n  return self;\n}\nfunction PercentOfView(viewSize) {\n  function measure(n) {\n    return viewSize * (n / 100);\n  }\n  var self = {\n    measure: measure\n  };\n  return self;\n}\nfunction ScrollBody(location, baseSpeed, baseMass) {\n  var roundToTwoDecimals = roundToDecimals(2);\n  var velocity = Vector1D(0);\n  var acceleration = Vector1D(0);\n  var attraction = Vector1D(0);\n  var attractionDirection = 0;\n  var speed = baseSpeed;\n  var mass = baseMass;\n  function update() {\n    velocity.add(acceleration);\n    location.add(velocity);\n    acceleration.multiply(0);\n  }\n  function applyForce(force) {\n    force.divide(mass);\n    acceleration.add(force);\n  }\n  function seek(target) {\n    attraction.set(target).subtract(location);\n    var magnitude = map(attraction.get(), 0, 100, 0, speed);\n    attractionDirection = mathSign(attraction.get());\n    attraction.normalize().multiply(magnitude).subtract(velocity);\n    applyForce(attraction);\n    return self;\n  }\n  function settle(target) {\n    var diff = target.get() - location.get();\n    var hasSettled = !roundToTwoDecimals(diff);\n    if (hasSettled) location.set(target);\n    return hasSettled;\n  }\n  function direction() {\n    return attractionDirection;\n  }\n  function useBaseSpeed() {\n    return useSpeed(baseSpeed);\n  }\n  function useBaseMass() {\n    return useMass(baseMass);\n  }\n  function useSpeed(n) {\n    speed = n;\n    return self;\n  }\n  function useMass(n) {\n    mass = n;\n    return self;\n  }\n  var self = {\n    direction: direction,\n    seek: seek,\n    settle: settle,\n    update: update,\n    useBaseMass: useBaseMass,\n    useBaseSpeed: useBaseSpeed,\n    useMass: useMass,\n    useSpeed: useSpeed\n  };\n  return self;\n}\nfunction ScrollBounds(limit, location, target, scrollBody, percentOfView) {\n  var pullBackThreshold = percentOfView.measure(10);\n  var edgeOffsetTolerance = percentOfView.measure(50);\n  var maxFriction = 0.85;\n  var disabled = false;\n  function shouldConstrain() {\n    if (disabled) return false;\n    if (!limit.reachedAny(target.get())) return false;\n    if (!limit.reachedAny(location.get())) return false;\n    return true;\n  }\n  function constrain(pointerDown) {\n    if (!shouldConstrain()) return;\n    var edge = limit.reachedMin(location.get()) ? 'min' : 'max';\n    var diffToEdge = mathAbs(limit[edge] - location.get());\n    var diffToTarget = target.get() - location.get();\n    var friction = Math.min(diffToEdge / edgeOffsetTolerance, maxFriction);\n    target.subtract(diffToTarget * friction);\n    if (!pointerDown && mathAbs(diffToTarget) < pullBackThreshold) {\n      target.set(limit.constrain(target.get()));\n      scrollBody.useSpeed(10).useMass(3);\n    }\n  }\n  function toggleActive(active) {\n    disabled = !active;\n  }\n  var self = {\n    constrain: constrain,\n    toggleActive: toggleActive\n  };\n  return self;\n}\nfunction ScrollContain(viewSize, contentSize, snapsAligned, containScroll) {\n  var scrollBounds = Limit(-contentSize + viewSize, snapsAligned[0]);\n  var snapsBounded = snapsAligned.map(scrollBounds.constrain);\n  var snapsContained = measureContained();\n  function findDuplicates() {\n    var startSnap = snapsBounded[0];\n    var endSnap = arrayLast(snapsBounded);\n    var min = snapsBounded.lastIndexOf(startSnap);\n    var max = snapsBounded.indexOf(endSnap) + 1;\n    return Limit(min, max);\n  }\n  function measureContained() {\n    if (contentSize <= viewSize) return [scrollBounds.max];\n    if (containScroll === 'keepSnaps') return snapsBounded;\n    var _a = findDuplicates(),\n      min = _a.min,\n      max = _a.max;\n    return snapsBounded.slice(min, max);\n  }\n  var self = {\n    snapsContained: snapsContained\n  };\n  return self;\n}\nfunction ScrollLimit(contentSize, scrollSnaps, loop) {\n  var limit = measureLimit();\n  function measureLimit() {\n    var startSnap = scrollSnaps[0];\n    var endSnap = arrayLast(scrollSnaps);\n    var min = loop ? startSnap - contentSize : endSnap;\n    var max = startSnap;\n    return Limit(min, max);\n  }\n  var self = {\n    limit: limit\n  };\n  return self;\n}\nfunction ScrollLooper(contentSize, limit, location, vectors) {\n  var jointSafety = 0.1;\n  var min = limit.min + jointSafety;\n  var max = limit.max + jointSafety;\n  var _a = Limit(min, max),\n    reachedMin = _a.reachedMin,\n    reachedMax = _a.reachedMax;\n  function shouldLoop(direction) {\n    if (direction === 1) return reachedMax(location.get());\n    if (direction === -1) return reachedMin(location.get());\n    return false;\n  }\n  function loop(direction) {\n    if (!shouldLoop(direction)) return;\n    var loopDistance = contentSize * (direction * -1);\n    vectors.forEach(function (v) {\n      return v.add(loopDistance);\n    });\n  }\n  var self = {\n    loop: loop\n  };\n  return self;\n}\nfunction ScrollProgress(limit) {\n  var max = limit.max,\n    scrollLength = limit.length;\n  function get(n) {\n    var currentLocation = n - max;\n    return currentLocation / -scrollLength;\n  }\n  var self = {\n    get: get\n  };\n  return self;\n}\nfunction ScrollSnaps(axis, alignment, containerRect, slideRects, slideSizesWithGaps, slidesToScroll, containScroll) {\n  var startEdge = axis.startEdge,\n    endEdge = axis.endEdge;\n  var groupSlides = slidesToScroll.groupSlides;\n  var alignments = measureSizes().map(alignment.measure);\n  var snaps = measureUnaligned();\n  var snapsAligned = measureAligned();\n  function measureSizes() {\n    return groupSlides(slideRects).map(function (rects) {\n      return arrayLast(rects)[endEdge] - rects[0][startEdge];\n    }).map(mathAbs);\n  }\n  function measureUnaligned() {\n    return slideRects.map(function (rect) {\n      return containerRect[startEdge] - rect[startEdge];\n    }).map(function (snap) {\n      return -mathAbs(snap);\n    });\n  }\n  function measureAligned() {\n    var containedStartSnap = 0;\n    var containedEndSnap = arrayLast(snaps) - arrayLast(slideSizesWithGaps);\n    return groupSlides(snaps).map(function (g) {\n      return g[0];\n    }).map(function (snap, index, groupedSnaps) {\n      var isFirst = !index;\n      var isLast = index === arrayLastIndex(groupedSnaps);\n      if (containScroll && isFirst) return containedStartSnap;\n      if (containScroll && isLast) return containedEndSnap;\n      return snap + alignments[index];\n    });\n  }\n  var self = {\n    snaps: snaps,\n    snapsAligned: snapsAligned\n  };\n  return self;\n}\nfunction ScrollTarget(loop, scrollSnaps, contentSize, limit, targetVector) {\n  var reachedAny = limit.reachedAny,\n    removeOffset = limit.removeOffset,\n    constrain = limit.constrain;\n  function minDistance(distances) {\n    return distances.concat().sort(function (a, b) {\n      return mathAbs(a) - mathAbs(b);\n    })[0];\n  }\n  function findTargetSnap(target) {\n    var distance = loop ? removeOffset(target) : constrain(target);\n    var ascDiffsToSnaps = scrollSnaps.map(function (scrollSnap) {\n      return scrollSnap - distance;\n    }).map(function (diffToSnap) {\n      return shortcut(diffToSnap, 0);\n    }).map(function (diff, i) {\n      return {\n        diff: diff,\n        index: i\n      };\n    }).sort(function (d1, d2) {\n      return mathAbs(d1.diff) - mathAbs(d2.diff);\n    });\n    var index = ascDiffsToSnaps[0].index;\n    return {\n      index: index,\n      distance: distance\n    };\n  }\n  function shortcut(target, direction) {\n    var targets = [target, target + contentSize, target - contentSize];\n    if (!loop) return targets[0];\n    if (!direction) return minDistance(targets);\n    var matchingTargets = targets.filter(function (t) {\n      return mathSign(t) === direction;\n    });\n    return minDistance(matchingTargets);\n  }\n  function byIndex(index, direction) {\n    var diffToSnap = scrollSnaps[index] - targetVector.get();\n    var distance = shortcut(diffToSnap, direction);\n    return {\n      index: index,\n      distance: distance\n    };\n  }\n  function byDistance(distance, snap) {\n    var target = targetVector.get() + distance;\n    var _a = findTargetSnap(target),\n      index = _a.index,\n      targetSnapDistance = _a.distance;\n    var reachedBound = !loop && reachedAny(target);\n    if (!snap || reachedBound) return {\n      index: index,\n      distance: distance\n    };\n    var diffToSnap = scrollSnaps[index] - targetSnapDistance;\n    var snapDistance = distance + shortcut(diffToSnap, 0);\n    return {\n      index: index,\n      distance: snapDistance\n    };\n  }\n  var self = {\n    byDistance: byDistance,\n    byIndex: byIndex,\n    shortcut: shortcut\n  };\n  return self;\n}\nfunction ScrollTo(animation, indexCurrent, indexPrevious, scrollTarget, targetVector, eventHandler) {\n  function scrollTo(target) {\n    var distanceDiff = target.distance;\n    var indexDiff = target.index !== indexCurrent.get();\n    if (distanceDiff) {\n      animation.start();\n      targetVector.add(distanceDiff);\n    }\n    if (indexDiff) {\n      indexPrevious.set(indexCurrent.get());\n      indexCurrent.set(target.index);\n      eventHandler.emit('select');\n    }\n  }\n  function distance(n, snap) {\n    var target = scrollTarget.byDistance(n, snap);\n    scrollTo(target);\n  }\n  function index(n, direction) {\n    var targetIndex = indexCurrent.clone().set(n);\n    var target = scrollTarget.byIndex(targetIndex.get(), direction);\n    scrollTo(target);\n  }\n  var self = {\n    distance: distance,\n    index: index\n  };\n  return self;\n}\nfunction Translate(axis, direction, container) {\n  var translate = axis.scroll === 'x' ? x : y;\n  var containerStyle = container.style;\n  var disabled = false;\n  function x(n) {\n    return \"translate3d(\".concat(n, \"px,0px,0px)\");\n  }\n  function y(n) {\n    return \"translate3d(0px,\".concat(n, \"px,0px)\");\n  }\n  function to(target) {\n    if (disabled) return;\n    containerStyle.transform = translate(direction.apply(target.get()));\n  }\n  function toggleActive(active) {\n    disabled = !active;\n  }\n  function clear() {\n    if (disabled) return;\n    containerStyle.transform = '';\n    if (!container.getAttribute('style')) container.removeAttribute('style');\n  }\n  var self = {\n    clear: clear,\n    to: to,\n    toggleActive: toggleActive\n  };\n  return self;\n}\nfunction SlideLooper(axis, direction, viewSize, contentSize, slideSizesWithGaps, scrollSnaps, slidesInView, scroll, slides) {\n  var ascItems = arrayKeys(slideSizesWithGaps);\n  var descItems = arrayKeys(slideSizesWithGaps).reverse();\n  var loopPoints = startPoints().concat(endPoints());\n  function removeSlideSizes(indexes, from) {\n    return indexes.reduce(function (a, i) {\n      return a - slideSizesWithGaps[i];\n    }, from);\n  }\n  function slidesInGap(indexes, gap) {\n    return indexes.reduce(function (a, i) {\n      var remainingGap = removeSlideSizes(a, gap);\n      return remainingGap > 0 ? a.concat([i]) : a;\n    }, []);\n  }\n  function findLoopPoints(indexes, edge) {\n    var isStartEdge = edge === 'start';\n    var offset = isStartEdge ? -contentSize : contentSize;\n    var slideBounds = slidesInView.findSlideBounds([offset]);\n    return indexes.map(function (index) {\n      var initial = isStartEdge ? 0 : -contentSize;\n      var altered = isStartEdge ? contentSize : 0;\n      var bounds = slideBounds.filter(function (b) {\n        return b.index === index;\n      })[0];\n      var point = bounds[isStartEdge ? 'end' : 'start'];\n      var shift = Vector1D(-1);\n      var location = Vector1D(-1);\n      var translate = Translate(axis, direction, slides[index]);\n      var target = function target() {\n        return shift.set(scroll.get() > point ? initial : altered);\n      };\n      return {\n        index: index,\n        location: location,\n        translate: translate,\n        target: target\n      };\n    });\n  }\n  function startPoints() {\n    var gap = scrollSnaps[0] - 1;\n    var indexes = slidesInGap(descItems, gap);\n    return findLoopPoints(indexes, 'end');\n  }\n  function endPoints() {\n    var gap = viewSize - scrollSnaps[0] - 1;\n    var indexes = slidesInGap(ascItems, gap);\n    return findLoopPoints(indexes, 'start');\n  }\n  function canLoop() {\n    return loopPoints.every(function (_a) {\n      var index = _a.index;\n      var otherIndexes = ascItems.filter(function (i) {\n        return i !== index;\n      });\n      return removeSlideSizes(otherIndexes, viewSize) <= 0.1;\n    });\n  }\n  function loop() {\n    loopPoints.forEach(function (loopPoint) {\n      var target = loopPoint.target,\n        translate = loopPoint.translate,\n        location = loopPoint.location;\n      var shift = target();\n      if (shift.get() === location.get()) return;\n      if (shift.get() === 0) translate.clear();else translate.to(shift);\n      location.set(shift);\n    });\n  }\n  function clear() {\n    loopPoints.forEach(function (loopPoint) {\n      return loopPoint.translate.clear();\n    });\n  }\n  var self = {\n    canLoop: canLoop,\n    clear: clear,\n    loop: loop,\n    loopPoints: loopPoints\n  };\n  return self;\n}\nfunction SlidesInView(viewSize, contentSize, slideSizes, snaps, limit, loop, inViewThreshold) {\n  var removeOffset = limit.removeOffset,\n    constrain = limit.constrain;\n  var roundingSafety = 0.5;\n  var cachedOffsets = loop ? [0, contentSize, -contentSize] : [0];\n  var cachedBounds = findSlideBounds(cachedOffsets, inViewThreshold);\n  function findSlideThresholds(threshold) {\n    var slideThreshold = threshold || 0;\n    return slideSizes.map(function (slideSize) {\n      var thresholdLimit = Limit(roundingSafety, slideSize - roundingSafety);\n      return thresholdLimit.constrain(slideSize * slideThreshold);\n    });\n  }\n  function findSlideBounds(offsets, threshold) {\n    var slideOffsets = offsets || cachedOffsets;\n    var slideThresholds = findSlideThresholds(threshold);\n    return slideOffsets.reduce(function (list, offset) {\n      var bounds = snaps.map(function (snap, index) {\n        return {\n          start: snap - slideSizes[index] + slideThresholds[index] + offset,\n          end: snap + viewSize - slideThresholds[index] + offset,\n          index: index\n        };\n      });\n      return list.concat(bounds);\n    }, []);\n  }\n  function check(location, bounds) {\n    var limitedLocation = loop ? removeOffset(location) : constrain(location);\n    var slideBounds = bounds || cachedBounds;\n    return slideBounds.reduce(function (list, slideBound) {\n      var index = slideBound.index,\n        start = slideBound.start,\n        end = slideBound.end;\n      var inList = list.indexOf(index) !== -1;\n      var inView = start < limitedLocation && end > limitedLocation;\n      return !inList && inView ? list.concat([index]) : list;\n    }, []);\n  }\n  var self = {\n    check: check,\n    findSlideBounds: findSlideBounds\n  };\n  return self;\n}\nfunction SlideSizes(axis, containerRect, slideRects, slides, includeEdgeGap) {\n  var measureSize = axis.measureSize,\n    startEdge = axis.startEdge,\n    endEdge = axis.endEdge;\n  var startGap = measureStartGap();\n  var endGap = measureEndGap();\n  var slideSizes = slideRects.map(measureSize);\n  var slideSizesWithGaps = measureWithGaps();\n  function measureStartGap() {\n    if (!includeEdgeGap) return 0;\n    var slideRect = slideRects[0];\n    return mathAbs(containerRect[startEdge] - slideRect[startEdge]);\n  }\n  function measureEndGap() {\n    if (!includeEdgeGap) return 0;\n    var style = window.getComputedStyle(arrayLast(slides));\n    return parseFloat(style.getPropertyValue(\"margin-\".concat(endEdge)));\n  }\n  function measureWithGaps() {\n    return slideRects.map(function (rect, index, rects) {\n      var isFirst = !index;\n      var isLast = index === arrayLastIndex(rects);\n      if (isFirst) return slideSizes[index] + startGap;\n      if (isLast) return slideSizes[index] + endGap;\n      return rects[index + 1][startEdge] - rect[startEdge];\n    }).map(mathAbs);\n  }\n  var self = {\n    slideSizes: slideSizes,\n    slideSizesWithGaps: slideSizesWithGaps\n  };\n  return self;\n}\nfunction SlidesToScroll(viewSize, slideSizesWithGaps, slidesToScroll) {\n  var groupByNumber = isNumber(slidesToScroll);\n  function byNumber(array, groupSize) {\n    return arrayKeys(array).filter(function (i) {\n      return i % groupSize === 0;\n    }).map(function (i) {\n      return array.slice(i, i + groupSize);\n    });\n  }\n  function bySize(array) {\n    return arrayKeys(array).reduce(function (groupSizes, i) {\n      var chunk = slideSizesWithGaps.slice(arrayLast(groupSizes), i + 1);\n      var chunkSize = chunk.reduce(function (a, s) {\n        return a + s;\n      }, 0);\n      return !i || chunkSize > viewSize ? groupSizes.concat(i) : groupSizes;\n    }, []).map(function (start, i, groupSizes) {\n      return array.slice(start, groupSizes[i + 1]);\n    });\n  }\n  function groupSlides(array) {\n    return groupByNumber ? byNumber(array, slidesToScroll) : bySize(array);\n  }\n  var self = {\n    groupSlides: groupSlides\n  };\n  return self;\n}\nfunction Engine(root, container, slides, options, eventHandler) {\n  // Options\n  var align = options.align,\n    scrollAxis = options.axis,\n    contentDirection = options.direction,\n    startIndex = options.startIndex,\n    inViewThreshold = options.inViewThreshold,\n    loop = options.loop,\n    speed = options.speed,\n    dragFree = options.dragFree,\n    groupSlides = options.slidesToScroll,\n    skipSnaps = options.skipSnaps,\n    containScroll = options.containScroll; // Measurements\n\n  var containerRect = container.getBoundingClientRect();\n  var slideRects = slides.map(function (slide) {\n    return slide.getBoundingClientRect();\n  });\n  var direction = Direction(contentDirection);\n  var axis = Axis(scrollAxis, contentDirection);\n  var viewSize = axis.measureSize(containerRect);\n  var percentOfView = PercentOfView(viewSize);\n  var alignment = Alignment(align, viewSize);\n  var containSnaps = !loop && containScroll !== '';\n  var includeEdgeGap = loop || containScroll !== '';\n  var _a = SlideSizes(axis, containerRect, slideRects, slides, includeEdgeGap),\n    slideSizes = _a.slideSizes,\n    slideSizesWithGaps = _a.slideSizesWithGaps;\n  var slidesToScroll = SlidesToScroll(viewSize, slideSizesWithGaps, groupSlides);\n  var _b = ScrollSnaps(axis, alignment, containerRect, slideRects, slideSizesWithGaps, slidesToScroll, containSnaps),\n    snaps = _b.snaps,\n    snapsAligned = _b.snapsAligned;\n  var contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps);\n  var snapsContained = ScrollContain(viewSize, contentSize, snapsAligned, containScroll).snapsContained;\n  var scrollSnaps = containSnaps ? snapsContained : snapsAligned;\n  var limit = ScrollLimit(contentSize, scrollSnaps, loop).limit; // Indexes\n\n  var index = Counter(arrayLastIndex(scrollSnaps), startIndex, loop);\n  var indexPrevious = index.clone();\n  var slideIndexes = arrayKeys(slides); // Draw\n\n  var update = function update() {\n    if (!loop) engine.scrollBounds.constrain(engine.dragHandler.pointerDown());\n    engine.scrollBody.seek(target).update();\n    var settled = engine.scrollBody.settle(target);\n    if (settled && !engine.dragHandler.pointerDown()) {\n      engine.animation.stop();\n      eventHandler.emit('settle');\n    }\n    if (!settled) {\n      eventHandler.emit('scroll');\n    }\n    if (loop) {\n      engine.scrollLooper.loop(engine.scrollBody.direction());\n      engine.slideLooper.loop();\n    }\n    engine.translate.to(location);\n    engine.animation.proceed();\n  }; // Shared\n\n  var animation = Animation(update);\n  var startLocation = scrollSnaps[index.get()];\n  var location = Vector1D(startLocation);\n  var target = Vector1D(startLocation);\n  var scrollBody = ScrollBody(location, speed, 1);\n  var scrollTarget = ScrollTarget(loop, scrollSnaps, contentSize, limit, target);\n  var scrollTo = ScrollTo(animation, index, indexPrevious, scrollTarget, target, eventHandler);\n  var slidesInView = SlidesInView(viewSize, contentSize, slideSizes, snaps, limit, loop, inViewThreshold); // DragHandler\n\n  var dragHandler = DragHandler(axis, direction, root, target, DragTracker(axis), location, animation, scrollTo, scrollBody, scrollTarget, index, eventHandler, percentOfView, loop, dragFree, skipSnaps); // Engine\n\n  var engine = {\n    containerRect: containerRect,\n    slideRects: slideRects,\n    animation: animation,\n    axis: axis,\n    direction: direction,\n    dragHandler: dragHandler,\n    eventStore: EventStore(),\n    percentOfView: percentOfView,\n    index: index,\n    indexPrevious: indexPrevious,\n    limit: limit,\n    location: location,\n    options: options,\n    scrollBody: scrollBody,\n    scrollBounds: ScrollBounds(limit, location, target, scrollBody, percentOfView),\n    scrollLooper: ScrollLooper(contentSize, limit, location, [location, target]),\n    scrollProgress: ScrollProgress(limit),\n    scrollSnaps: scrollSnaps,\n    scrollTarget: scrollTarget,\n    scrollTo: scrollTo,\n    slideLooper: SlideLooper(axis, direction, viewSize, contentSize, slideSizesWithGaps, scrollSnaps, slidesInView, location, slides),\n    slidesToScroll: slidesToScroll,\n    slidesInView: slidesInView,\n    slideIndexes: slideIndexes,\n    target: target,\n    translate: Translate(axis, direction, container)\n  };\n  return engine;\n}\nfunction EventHandler() {\n  var listeners = {};\n  function getListeners(evt) {\n    return listeners[evt] || [];\n  }\n  function emit(evt) {\n    getListeners(evt).forEach(function (e) {\n      return e(evt);\n    });\n    return self;\n  }\n  function on(evt, cb) {\n    listeners[evt] = getListeners(evt).concat([cb]);\n    return self;\n  }\n  function off(evt, cb) {\n    listeners[evt] = getListeners(evt).filter(function (e) {\n      return e !== cb;\n    });\n    return self;\n  }\n  var self = {\n    emit: emit,\n    off: off,\n    on: on\n  };\n  return self;\n}\nvar defaultOptions = {\n  align: 'center',\n  axis: 'x',\n  containScroll: '',\n  direction: 'ltr',\n  slidesToScroll: 1,\n  breakpoints: {},\n  dragFree: false,\n  draggable: true,\n  inViewThreshold: 0,\n  loop: false,\n  skipSnaps: false,\n  speed: 10,\n  startIndex: 0,\n  active: true\n};\nfunction OptionsHandler() {\n  function merge(optionsA, optionsB) {\n    return objectsMergeDeep(optionsA, optionsB || {});\n  }\n  function areEqual(optionsA, optionsB) {\n    var breakpointsA = JSON.stringify(objectKeys(optionsA.breakpoints || {}));\n    var breakpointsB = JSON.stringify(objectKeys(optionsB.breakpoints || {}));\n    if (breakpointsA !== breakpointsB) return false;\n    return objectsAreEqual(optionsA, optionsB);\n  }\n  function atMedia(options) {\n    var optionsAtMedia = options.breakpoints || {};\n    var matchedMediaOptions = objectKeys(optionsAtMedia).filter(function (media) {\n      return window.matchMedia(media).matches;\n    }).map(function (media) {\n      return optionsAtMedia[media];\n    }).reduce(function (a, mediaOption) {\n      return merge(a, mediaOption);\n    }, {});\n    return merge(options, matchedMediaOptions);\n  }\n  var self = {\n    merge: merge,\n    areEqual: areEqual,\n    atMedia: atMedia\n  };\n  return self;\n}\nfunction PluginsHandler() {\n  var _a = OptionsHandler(),\n    atMedia = _a.atMedia,\n    areEqual = _a.areEqual;\n  var activePlugins = [];\n  var pluginsChanged = [];\n  function haveChanged() {\n    return pluginsChanged.some(function (hasChanged) {\n      return hasChanged();\n    });\n  }\n  function hasChanged(plugin) {\n    var options = atMedia(plugin.options);\n    return function () {\n      return !areEqual(options, atMedia(plugin.options));\n    };\n  }\n  function init(plugins, embla) {\n    pluginsChanged = plugins.map(hasChanged);\n    activePlugins = plugins.filter(function (plugin) {\n      return atMedia(plugin.options).active;\n    });\n    activePlugins.forEach(function (plugin) {\n      return plugin.init(embla);\n    });\n    return plugins.reduce(function (map, plugin) {\n      var _a;\n      return Object.assign(map, (_a = {}, _a[plugin.name] = plugin, _a));\n    }, {});\n  }\n  function destroy() {\n    activePlugins = activePlugins.filter(function (plugin) {\n      return plugin.destroy();\n    });\n  }\n  var self = {\n    init: init,\n    destroy: destroy,\n    haveChanged: haveChanged\n  };\n  return self;\n}\nfunction EmblaCarousel(nodes, userOptions, userPlugins) {\n  var resizeHandlers = EventStore();\n  var optionsHandler = OptionsHandler();\n  var pluginsHandler = PluginsHandler();\n  var eventHandler = EventHandler();\n  var on = eventHandler.on,\n    off = eventHandler.off;\n  var reInit = reActivate;\n  var destroyed = false;\n  var engine;\n  var optionsBase = optionsHandler.merge(defaultOptions, EmblaCarousel.globalOptions);\n  var options = optionsHandler.merge(optionsBase);\n  var pluginList = [];\n  var pluginApis;\n  var rootSize = 0;\n  var root;\n  var container;\n  var slides;\n  function storeElements() {\n    var providedContainer = 'container' in nodes && nodes.container;\n    var providedSlides = 'slides' in nodes && nodes.slides;\n    root = 'root' in nodes ? nodes.root : nodes;\n    container = providedContainer || root.children[0];\n    slides = providedSlides || [].slice.call(container.children);\n  }\n  function activate(withOptions, withPlugins) {\n    if (destroyed) return;\n    storeElements();\n    optionsBase = optionsHandler.merge(optionsBase, withOptions);\n    options = optionsHandler.atMedia(optionsBase);\n    engine = Engine(root, container, slides, options, eventHandler);\n    rootSize = engine.axis.measureSize(root.getBoundingClientRect());\n    if (!options.active) return deActivate();\n    engine.translate.to(engine.location);\n    pluginList = withPlugins || pluginList;\n    pluginApis = pluginsHandler.init(pluginList, self);\n    if (options.loop) {\n      if (!engine.slideLooper.canLoop()) {\n        deActivate();\n        return activate({\n          loop: false\n        }, withPlugins);\n      }\n      engine.slideLooper.loop();\n    }\n    if (options.draggable && container.offsetParent && slides.length) {\n      engine.dragHandler.addActivationEvents();\n    }\n  }\n  function reActivate(withOptions, withPlugins) {\n    var startIndex = selectedScrollSnap();\n    deActivate();\n    activate(optionsHandler.merge({\n      startIndex: startIndex\n    }, withOptions), withPlugins);\n    eventHandler.emit('reInit');\n  }\n  function deActivate() {\n    engine.dragHandler.removeAllEvents();\n    engine.animation.stop();\n    engine.eventStore.removeAll();\n    engine.translate.clear();\n    engine.slideLooper.clear();\n    pluginsHandler.destroy();\n  }\n  function destroy() {\n    if (destroyed) return;\n    destroyed = true;\n    resizeHandlers.removeAll();\n    deActivate();\n    eventHandler.emit('destroy');\n  }\n  function resize() {\n    var newOptions = optionsHandler.atMedia(optionsBase);\n    var optionsChanged = !optionsHandler.areEqual(newOptions, options);\n    var newRootSize = engine.axis.measureSize(root.getBoundingClientRect());\n    var rootSizeChanged = rootSize !== newRootSize;\n    var pluginsChanged = pluginsHandler.haveChanged();\n    if (rootSizeChanged || optionsChanged || pluginsChanged) reActivate();\n    eventHandler.emit('resize');\n  }\n  function slidesInView(target) {\n    var location = engine[target ? 'target' : 'location'].get();\n    var type = options.loop ? 'removeOffset' : 'constrain';\n    return engine.slidesInView.check(engine.limit[type](location));\n  }\n  function slidesNotInView(target) {\n    var inView = slidesInView(target);\n    return engine.slideIndexes.filter(function (index) {\n      return inView.indexOf(index) === -1;\n    });\n  }\n  function scrollTo(index, jump, direction) {\n    if (!options.active || destroyed) return;\n    engine.scrollBody.useBaseMass().useSpeed(jump ? 100 : options.speed);\n    engine.scrollTo.index(index, direction || 0);\n  }\n  function scrollNext(jump) {\n    var next = engine.index.clone().add(1);\n    scrollTo(next.get(), jump === true, -1);\n  }\n  function scrollPrev(jump) {\n    var prev = engine.index.clone().add(-1);\n    scrollTo(prev.get(), jump === true, 1);\n  }\n  function canScrollNext() {\n    var next = engine.index.clone().add(1);\n    return next.get() !== selectedScrollSnap();\n  }\n  function canScrollPrev() {\n    var prev = engine.index.clone().add(-1);\n    return prev.get() !== selectedScrollSnap();\n  }\n  function scrollSnapList() {\n    return engine.scrollSnaps.map(engine.scrollProgress.get);\n  }\n  function scrollProgress() {\n    return engine.scrollProgress.get(engine.location.get());\n  }\n  function selectedScrollSnap() {\n    return engine.index.get();\n  }\n  function previousScrollSnap() {\n    return engine.indexPrevious.get();\n  }\n  function clickAllowed() {\n    return engine.dragHandler.clickAllowed();\n  }\n  function plugins() {\n    return pluginApis;\n  }\n  function internalEngine() {\n    return engine;\n  }\n  function rootNode() {\n    return root;\n  }\n  function containerNode() {\n    return container;\n  }\n  function slideNodes() {\n    return slides;\n  }\n  var self = {\n    canScrollNext: canScrollNext,\n    canScrollPrev: canScrollPrev,\n    clickAllowed: clickAllowed,\n    containerNode: containerNode,\n    internalEngine: internalEngine,\n    destroy: destroy,\n    off: off,\n    on: on,\n    plugins: plugins,\n    previousScrollSnap: previousScrollSnap,\n    reInit: reInit,\n    rootNode: rootNode,\n    scrollNext: scrollNext,\n    scrollPrev: scrollPrev,\n    scrollProgress: scrollProgress,\n    scrollSnapList: scrollSnapList,\n    scrollTo: scrollTo,\n    selectedScrollSnap: selectedScrollSnap,\n    slideNodes: slideNodes,\n    slidesInView: slidesInView,\n    slidesNotInView: slidesNotInView\n  };\n  activate(userOptions, userPlugins);\n  resizeHandlers.add(window, 'resize', resize);\n  setTimeout(function () {\n    return eventHandler.emit('init');\n  }, 0);\n  return self;\n}\nEmblaCarousel.globalOptions = undefined;\nEmblaCarousel.optionsHandler = OptionsHandler;\nexport { EmblaCarousel as default };","map":{"version":3,"sources":["src/components/utils.ts","src/components/Alignment.ts","src/components/Animation.ts","src/components/Axis.ts","src/components/Limit.ts","src/components/Counter.ts","src/components/Direction.ts","src/components/EventStore.ts","src/components/Vector1d.ts","src/components/DragHandler.ts","src/components/DragTracker.ts","src/components/PercentOfView.ts","src/components/ScrollBody.ts","src/components/ScrollBounds.ts","src/components/ScrollContain.ts","src/components/ScrollLimit.ts","src/components/ScrollLooper.ts","src/components/ScrollProgress.ts","src/components/ScrollSnaps.ts","src/components/ScrollTarget.ts","src/components/ScrollTo.ts","src/components/Translate.ts","src/components/SlideLooper.ts","src/components/SlidesInView.ts","src/components/SlideSizes.ts","src/components/SlidesToScroll.ts","src/components/Engine.ts","src/components/EventHandler.ts","src/components/Options.ts","src/components/OptionsHandler.ts","src/components/PluginsHandler.ts","src/components/index.ts"],"names":["map","value","iStart","iStop","oStart","oStop","isNumber","subject","isObject","Object","prototype","toString","call","isArray","Array","isRecord","mathAbs","n","Math","abs","mathSign","valueB","valueA","diff","deltaAbs","roundToDecimals","decimalPoints","pow","round","arrayKeys","array","objectKeys","Number","arrayLast","arrayLastIndex","max","length","object","keys","objectA","objectB","reduce","mergedObjects","currentObject","forEach","key","areObjects","objectsMergeDeep","objectAKeys","objectBKeys","every","concat","objectsAreEqual","align","viewSize","predefined","start","center","end","percent","measure","self","Animation","callback","animationFrame","ifAnimating","active","cb","window","requestAnimationFrame","stop","cancelAnimationFrame","proceed","axis","direction","scroll","cross","startEdge","getStartEdge","endEdge","getEndEdge","measureSize","rect","height","width","min","reachedMin","reachedMax","reachedAny","constrain","removeOffset","ceil","Counter","loop","loopEnd","counter","withinLimit","get","set","add","clone","Direction","sign","apply","EventStore","listeners","node","type","handler","addEventListener","options","push","removeEventListener","removeAll","filter","remove","Vector1D","vector","readNumber","subtract","multiply","divide","normalize","rootNode","target","dragTracker","location","animation","scrollTo","scrollBody","scrollTarget","index","eventHandler","percentOfView","dragFree","skipSnaps","crossAxis","focusNodes","dragStartPoint","activationEvents","interactionEvents","dragThreshold","snapForceBoost","mouse","touch","freeForceBoost","baseSpeed","baseMass","startScroll","startCross","pointerIsDown","preventScroll","preventClick","isMouse","addActivationEvents","down","up","click","addInteractionEvents","document","move","removeAllEvents","isFocusNode","name","nodeName","indexOf","forceBoost","boost","allowedForce","force","targetChanged","next","isEdge","baseForce","byDistance","distance","byIndex","evt","button","isMoving","clearPreventClick","isNotFocusNode","preventDefault","pointerDown","useBaseMass","useSpeed","readPoint","emit","cancelable","lastScroll","lastCross","diffScroll","diffCross","pointerMove","currentLocation","rawForce","pointerUp","forceFactor","factorAbs","isVigorous","isBelowThreshold","speed","mass","useMass","clickAllowed","DragTracker","logInterval","startEvent","lastEvent","isTouchEvent","TouchEvent","readTime","timeStamp","evtAxis","property","coord","touches","expired","diffDrag","diffTime","isFlick","PercentOfView","ScrollBody","roundToTwoDecimals","velocity","acceleration","attraction","attractionDirection","update","applyForce","seek","magnitude","settle","hasSettled","useBaseSpeed","ScrollBounds","limit","pullBackThreshold","edgeOffsetTolerance","maxFriction","disabled","shouldConstrain","edge","diffToEdge","diffToTarget","friction","toggleActive","ScrollContain","contentSize","snapsAligned","containScroll","scrollBounds","Limit","snapsBounded","snapsContained","measureContained","findDuplicates","startSnap","endSnap","lastIndexOf","slice","ScrollLimit","scrollSnaps","measureLimit","ScrollLooper","vectors","jointSafety","shouldLoop","loopDistance","v","ScrollProgress","scrollLength","alignment","containerRect","slideRects","slideSizesWithGaps","slidesToScroll","alignments","measureSizes","snaps","measureUnaligned","measureAligned","rects","snap","containedStartSnap","containedEndSnap","g","groupedSnaps","isFirst","isLast","ScrollTarget","targetVector","minDistance","distances","sort","a","b","findTargetSnap","ascDiffsToSnaps","scrollSnap","diffToSnap","i","d1","d2","shortcut","targets","matchingTargets","t","targetSnapDistance","reachedBound","snapDistance","indexCurrent","indexPrevious","distanceDiff","indexDiff","targetIndex","Translate","container","translate","x","y","containerStyle","style","to","transform","clear","getAttribute","removeAttribute","SlideLooper","slidesInView","slides","ascItems","descItems","reverse","loopPoints","startPoints","endPoints","removeSlideSizes","indexes","from","slidesInGap","gap","remainingGap","findLoopPoints","isStartEdge","offset","slideBounds","findSlideBounds","initial","altered","bounds","point","shift","canLoop","_a","otherIndexes","loopPoint","slideSizes","inViewThreshold","roundingSafety","cachedOffsets","cachedBounds","findSlideThresholds","threshold","slideThreshold","slideSize","thresholdLimit","offsets","slideOffsets","slideThresholds","list","check","limitedLocation","slideBound","inList","inView","SlideSizes","includeEdgeGap","startGap","measureStartGap","endGap","measureEndGap","measureWithGaps","slideRect","getComputedStyle","parseFloat","getPropertyValue","SlidesToScroll","groupByNumber","byNumber","groupSize","bySize","groupSizes","chunk","chunkSize","s","groupSlides","Engine","root","scrollAxis","contentDirection","startIndex","getBoundingClientRect","slide","Axis","Alignment","containSnaps","ScrollSnaps","slideIndexes","engine","dragHandler","settled","scrollLooper","slideLooper","startLocation","ScrollTo","SlidesInView","DragHandler","eventStore","scrollProgress","EventHandler","getListeners","e","on","off","defaultOptions","breakpoints","draggable","OptionsHandler","merge","optionsA","optionsB","areEqual","breakpointsA","JSON","stringify","breakpointsB","atMedia","optionsAtMedia","matchedMediaOptions","media","matchMedia","matches","mediaOption","PluginsHandler","activePlugins","pluginsChanged","haveChanged","some","hasChanged","plugin","init","plugins","embla","assign","destroy","EmblaCarousel","nodes","userOptions","userPlugins","resizeHandlers","optionsHandler","pluginsHandler","reInit","reActivate","destroyed","optionsBase","globalOptions","pluginList","pluginApis","rootSize","storeElements","providedContainer","providedSlides","children","activate","withOptions","withPlugins","deActivate","offsetParent","selectedScrollSnap","resize","newOptions","optionsChanged","newRootSize","rootSizeChanged","slidesNotInView","jump","scrollNext","scrollPrev","prev","canScrollNext","canScrollPrev","scrollSnapList","previousScrollSnap","internalEngine","containerNode","slideNodes","setTimeout","undefined"],"mappings":"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","sourcesContent":["export function map(\n  value: number,\n  iStart: number,\n  iStop: number,\n  oStart: number,\n  oStop: number,\n): number {\n  return oStart + (oStop - oStart) * ((value - iStart) / (iStop - iStart))\n}\n\nexport function isNumber(subject: unknown): subject is number {\n  return typeof subject === 'number'\n}\n\nexport function isObject(subject: unknown): subject is Record<string, unknown> {\n  return Object.prototype.toString.call(subject) === '[object Object]'\n}\n\nexport function isArray(subject: unknown): subject is Record<number, unknown> {\n  return Array.isArray(subject)\n}\n\nexport function isRecord(\n  subject: unknown,\n): subject is Record<string | number, unknown> {\n  return isObject(subject) || isArray(subject)\n}\n\nexport function mathAbs(n: number): number {\n  return Math.abs(n)\n}\n\nexport function mathSign(n: number): number {\n  return !n ? 0 : n / mathAbs(n)\n}\n\nexport function deltaAbs(valueB: number, valueA: number): number {\n  return mathAbs(valueB - valueA)\n}\n\nexport function factorAbs(valueB: number, valueA: number): number {\n  if (valueB === 0 || valueA === 0) return 0\n  if (mathAbs(valueB) <= mathAbs(valueA)) return 0\n  const diff = deltaAbs(mathAbs(valueB), mathAbs(valueA))\n  return mathAbs(diff / valueB)\n}\n\nexport function roundToDecimals(decimalPoints: number): (n: number) => number {\n  const pow = Math.pow(10, decimalPoints)\n  return (n: number): number => Math.round(n * pow) / pow\n}\n\nexport function arrayKeys<Type>(array: Type[]): number[] {\n  return objectKeys(array).map(Number)\n}\n\nexport function arrayLast<Type>(array: Type[]): Type {\n  return array[arrayLastIndex(array)]\n}\n\nexport function arrayLastIndex<Type>(array: Type[]): number {\n  return Math.max(0, array.length - 1)\n}\n\nexport function objectKeys<Type>(object: Type): string[] {\n  return Object.keys(object)\n}\n\nexport function objectsMergeDeep(\n  objectA: Record<string, unknown>,\n  objectB: Record<string, unknown>,\n): Record<string, unknown> {\n  return [objectA, objectB].reduce((mergedObjects, currentObject) => {\n    objectKeys(currentObject).forEach((key) => {\n      const valueA = mergedObjects[key]\n      const valueB = currentObject[key]\n      const areObjects = isObject(valueA) && isObject(valueB)\n\n      mergedObjects[key] = areObjects\n        ? objectsMergeDeep(valueA, valueB)\n        : valueB\n    })\n    return mergedObjects\n  }, {})\n}\n\nexport function objectsAreEqual(\n  objectA: Record<string, unknown>,\n  objectB: Record<string, unknown>,\n): boolean {\n  const objectAKeys = objectKeys(objectA)\n  const objectBKeys = objectKeys(objectB)\n\n  if (objectAKeys.length !== objectBKeys.length) return false\n\n  return objectAKeys.every((key) => {\n    const valueA = objectA[key]\n    const valueB = objectB[key]\n    if (typeof valueA === 'function') return `${valueA}` === `${valueB}`\n    if (!isRecord(valueA) || !isRecord(valueB)) return valueA === valueB\n    return objectsAreEqual(valueA, valueB)\n  })\n}\n","import { isNumber } from './utils'\n\nexport type AlignmentOptionType = 'start' | 'center' | 'end' | number\n\nexport type AlignmentType = {\n  measure: (n: number) => number\n}\n\nexport function Alignment(\n  align: AlignmentOptionType,\n  viewSize: number,\n): AlignmentType {\n  const predefined = { start, center, end }\n\n  function start(): number {\n    return 0\n  }\n\n  function center(n: number): number {\n    return end(n) / 2\n  }\n\n  function end(n: number): number {\n    return viewSize - n\n  }\n\n  function percent(): number {\n    return viewSize * Number(align)\n  }\n\n  function measure(n: number): number {\n    if (isNumber(align)) return percent()\n    return predefined[align](n)\n  }\n\n  const self: AlignmentType = {\n    measure,\n  }\n  return self\n}\n","type CallbackType = () => void\n\nexport type AnimationType = {\n  start: () => void\n  stop: () => void\n  proceed: () => void\n}\n\nexport function Animation(callback: FrameRequestCallback): AnimationType {\n  let animationFrame = 0\n\n  function ifAnimating(active: boolean, cb: CallbackType): CallbackType {\n    return (): void => {\n      if (active === !!animationFrame) cb()\n    }\n  }\n\n  function start(): void {\n    animationFrame = window.requestAnimationFrame(callback)\n  }\n\n  function stop(): void {\n    window.cancelAnimationFrame(animationFrame)\n    animationFrame = 0\n  }\n\n  const self: AnimationType = {\n    proceed: ifAnimating(true, start),\n    start: ifAnimating(false, start),\n    stop: ifAnimating(true, stop),\n  }\n  return self\n}\n","import { DirectionOptionType } from './Direction'\n\nexport type AxisOptionType = 'x' | 'y'\ntype AxisEdgeType = 'top' | 'right' | 'bottom' | 'left'\n\nexport type AxisType = {\n  scroll: AxisOptionType\n  cross: AxisOptionType\n  startEdge: AxisEdgeType\n  endEdge: AxisEdgeType\n  measureSize: (rect: DOMRect) => number\n}\n\nexport function Axis(\n  axis: AxisOptionType,\n  direction: DirectionOptionType,\n): AxisType {\n  const scroll = axis === 'y' ? 'y' : 'x'\n  const cross = axis === 'y' ? 'x' : 'y'\n  const startEdge = getStartEdge()\n  const endEdge = getEndEdge()\n\n  function measureSize(rect: DOMRect): number {\n    const { width, height } = rect\n    return scroll === 'x' ? width : height\n  }\n\n  function getStartEdge(): AxisEdgeType {\n    if (scroll === 'y') return 'top'\n    return direction === 'rtl' ? 'right' : 'left'\n  }\n\n  function getEndEdge(): AxisEdgeType {\n    if (scroll === 'y') return 'bottom'\n    return direction === 'rtl' ? 'left' : 'right'\n  }\n\n  const self: AxisType = {\n    scroll,\n    cross,\n    startEdge,\n    endEdge,\n    measureSize,\n  }\n  return self\n}\n","import { mathAbs } from './utils'\n\nexport type LimitType = {\n  min: number\n  max: number\n  length: number\n  constrain: (n: number) => number\n  reachedAny: (n: number) => boolean\n  reachedMax: (n: number) => boolean\n  reachedMin: (n: number) => boolean\n  removeOffset: (n: number) => number\n}\n\nexport function Limit(min: number, max: number): LimitType {\n  const length = mathAbs(min - max)\n\n  function reachedMin(n: number): boolean {\n    return n < min\n  }\n\n  function reachedMax(n: number): boolean {\n    return n > max\n  }\n\n  function reachedAny(n: number): boolean {\n    return reachedMin(n) || reachedMax(n)\n  }\n\n  function constrain(n: number): number {\n    if (!reachedAny(n)) return n\n    return reachedMin(n) ? min : max\n  }\n\n  function removeOffset(n: number): number {\n    if (!length) return n\n    return n - length * Math.ceil((n - max) / length)\n  }\n\n  const self: LimitType = {\n    length,\n    max,\n    min,\n    constrain,\n    reachedAny,\n    reachedMax,\n    reachedMin,\n    removeOffset,\n  }\n  return self\n}\n","import { Limit } from './Limit'\nimport { mathAbs } from './utils'\n\nexport type CounterType = {\n  get: () => number\n  set: (n: number) => CounterType\n  add: (n: number) => CounterType\n  clone: () => CounterType\n  min: number\n  max: number\n}\n\nexport function Counter(\n  max: number,\n  start: number,\n  loop: boolean,\n): CounterType {\n  const { min, constrain } = Limit(0, max)\n  const loopEnd = max + 1\n  let counter = withinLimit(start)\n\n  function withinLimit(n: number): number {\n    return !loop ? constrain(n) : mathAbs((loopEnd + n) % loopEnd)\n  }\n\n  function get(): number {\n    return counter\n  }\n\n  function set(n: number): CounterType {\n    counter = withinLimit(n)\n    return self\n  }\n\n  function add(n: number): CounterType {\n    return set(get() + n)\n  }\n\n  function clone(): CounterType {\n    return Counter(max, get(), loop)\n  }\n\n  const self: CounterType = {\n    add,\n    clone,\n    get,\n    set,\n    min,\n    max,\n  }\n  return self\n}\n","export type DirectionOptionType = 'ltr' | 'rtl'\n\nexport type DirectionType = {\n  apply: (n: number) => number\n}\n\nexport function Direction(direction: DirectionOptionType): DirectionType {\n  const sign = direction === 'rtl' ? -1 : 1\n\n  function apply(n: number): number {\n    return n * sign\n  }\n\n  const self: DirectionType = {\n    apply,\n  }\n  return self\n}\n","type EventNameType = keyof DocumentEventMap | keyof WindowEventMap\ntype EventHandlerType = (evt: any) => void\ntype EventOptionsType = boolean | AddEventListenerOptions | undefined\ntype EventRemoverType = () => void\n\nexport type EventStoreType = {\n  add: (\n    node: EventTarget,\n    type: EventNameType,\n    handler: EventHandlerType,\n    options?: EventOptionsType,\n  ) => EventStoreType\n  removeAll: () => EventStoreType\n}\n\nexport function EventStore(): EventStoreType {\n  let listeners: EventRemoverType[] = []\n\n  function add(\n    node: EventTarget,\n    type: EventNameType,\n    handler: EventHandlerType,\n    options: EventOptionsType = false,\n  ): EventStoreType {\n    node.addEventListener(type, handler, options)\n    listeners.push(() => node.removeEventListener(type, handler, options))\n    return self\n  }\n\n  function removeAll(): EventStoreType {\n    listeners = listeners.filter((remove) => remove())\n    return self\n  }\n\n  const self: EventStoreType = {\n    add,\n    removeAll,\n  }\n  return self\n}\n","import { isNumber } from './utils'\n\nexport type Vector1DType = {\n  get: () => number\n  set: (v: Vector1DType | number) => Vector1DType\n  add: (v: Vector1DType | number) => Vector1DType\n  subtract: (v: Vector1DType | number) => Vector1DType\n  multiply: (n: number) => Vector1DType\n  divide: (n: number) => Vector1DType\n  normalize: () => Vector1DType\n}\n\nexport function Vector1D(value: number): Vector1DType {\n  let vector = value\n\n  function get(): number {\n    return vector\n  }\n\n  function set(n: Vector1DType | number): Vector1DType {\n    vector = readNumber(n)\n    return self\n  }\n\n  function add(n: Vector1DType | number): Vector1DType {\n    vector += readNumber(n)\n    return self\n  }\n\n  function subtract(n: Vector1DType | number): Vector1DType {\n    vector -= readNumber(n)\n    return self\n  }\n\n  function multiply(n: number): Vector1DType {\n    vector *= n\n    return self\n  }\n\n  function divide(n: number): Vector1DType {\n    vector /= n\n    return self\n  }\n\n  function normalize(): Vector1DType {\n    if (vector !== 0) divide(vector)\n    return self\n  }\n\n  function readNumber(n: Vector1DType | number): number {\n    return isNumber(n) ? n : n.get()\n  }\n\n  const self: Vector1DType = {\n    add,\n    divide,\n    get,\n    multiply,\n    normalize,\n    set,\n    subtract,\n  }\n  return self\n}\n","import { AnimationType } from './Animation'\nimport { CounterType } from './Counter'\nimport { DirectionType } from './Direction'\nimport { DragTrackerType, PointerEventType } from './DragTracker'\nimport { EventHandlerType } from './EventHandler'\nimport { AxisType } from './Axis'\nimport { EventStore } from './EventStore'\nimport { ScrollBodyType } from './ScrollBody'\nimport { ScrollTargetType } from './ScrollTarget'\nimport { ScrollToType } from './ScrollTo'\nimport { Vector1D, Vector1DType } from './Vector1d'\nimport { deltaAbs, factorAbs, mathAbs, mathSign } from './utils'\nimport { PercentOfViewType } from './PercentOfView'\n\nexport type DragHandlerType = {\n  addActivationEvents: () => void\n  clickAllowed: () => boolean\n  pointerDown: () => boolean\n  removeAllEvents: () => void\n}\n\nexport function DragHandler(\n  axis: AxisType,\n  direction: DirectionType,\n  rootNode: HTMLElement,\n  target: Vector1DType,\n  dragTracker: DragTrackerType,\n  location: Vector1DType,\n  animation: AnimationType,\n  scrollTo: ScrollToType,\n  scrollBody: ScrollBodyType,\n  scrollTarget: ScrollTargetType,\n  index: CounterType,\n  eventHandler: EventHandlerType,\n  percentOfView: PercentOfViewType,\n  loop: boolean,\n  dragFree: boolean,\n  skipSnaps: boolean,\n): DragHandlerType {\n  const { cross: crossAxis } = axis\n  const focusNodes = ['INPUT', 'SELECT', 'TEXTAREA']\n  const dragStartPoint = Vector1D(0)\n  const activationEvents = EventStore()\n  const interactionEvents = EventStore()\n  const dragThreshold = percentOfView.measure(20)\n  const snapForceBoost = { mouse: 300, touch: 400 }\n  const freeForceBoost = { mouse: 500, touch: 600 }\n  const baseSpeed = dragFree ? 5 : 16\n  const baseMass = 1\n\n  let startScroll = 0\n  let startCross = 0\n  let pointerIsDown = false\n  let preventScroll = false\n  let preventClick = false\n  let isMouse = false\n\n  function addActivationEvents(): void {\n    const node = rootNode\n    activationEvents\n      .add(node, 'touchmove', () => undefined)\n      .add(node, 'touchend', () => undefined)\n      .add(node, 'touchstart', down)\n      .add(node, 'mousedown', down)\n      .add(node, 'touchcancel', up)\n      .add(node, 'contextmenu', up)\n      .add(node, 'click', click)\n  }\n\n  function addInteractionEvents(): void {\n    const node = !isMouse ? rootNode : document\n    interactionEvents\n      .add(node, 'touchmove', move)\n      .add(node, 'touchend', up)\n      .add(node, 'mousemove', move)\n      .add(node, 'mouseup', up)\n  }\n\n  function removeAllEvents(): void {\n    activationEvents.removeAll()\n    interactionEvents.removeAll()\n  }\n\n  function isFocusNode(node: Element): boolean {\n    const name = node.nodeName || ''\n    return focusNodes.indexOf(name) > -1\n  }\n\n  function forceBoost(): number {\n    const boost = dragFree ? freeForceBoost : snapForceBoost\n    const type = isMouse ? 'mouse' : 'touch'\n    return boost[type]\n  }\n\n  function allowedForce(force: number, targetChanged: boolean): number {\n    const next = index.clone().add(mathSign(force) * -1)\n    const isEdge = next.get() === index.min || next.get() === index.max\n    const baseForce = scrollTarget.byDistance(force, !dragFree).distance\n\n    if (dragFree || mathAbs(force) < dragThreshold) return baseForce\n    if (!loop && isEdge) return baseForce * 0.4\n    if (skipSnaps && targetChanged) return baseForce * 0.5\n\n    return scrollTarget.byIndex(next.get(), 0).distance\n  }\n\n  function down(evt: PointerEventType): void {\n    isMouse = evt.type === 'mousedown'\n    if (isMouse && (evt as MouseEvent).button !== 0) return\n\n    const isMoving = deltaAbs(target.get(), location.get()) >= 2\n    const clearPreventClick = isMouse || !isMoving\n    const isNotFocusNode = !isFocusNode(evt.target as Element)\n    const preventDefault = isMoving || (isMouse && isNotFocusNode)\n\n    pointerIsDown = true\n    dragTracker.pointerDown(evt)\n    dragStartPoint.set(target)\n    target.set(location)\n    scrollBody.useBaseMass().useSpeed(80)\n    addInteractionEvents()\n    startScroll = dragTracker.readPoint(evt)\n    startCross = dragTracker.readPoint(evt, crossAxis)\n    eventHandler.emit('pointerDown')\n\n    if (clearPreventClick) preventClick = false\n    if (preventDefault) evt.preventDefault()\n  }\n\n  function move(evt: PointerEventType): void {\n    if (!preventScroll && !isMouse) {\n      if (!evt.cancelable) return up(evt)\n      const lastScroll = dragTracker.readPoint(evt)\n      const lastCross = dragTracker.readPoint(evt, crossAxis)\n      const diffScroll = deltaAbs(lastScroll, startScroll)\n      const diffCross = deltaAbs(lastCross, startCross)\n      preventScroll = diffScroll > diffCross\n      if (!preventScroll && !preventClick) return up(evt)\n    }\n    const diff = dragTracker.pointerMove(evt)\n    if (!preventClick && diff) preventClick = true\n    animation.start()\n    target.add(direction.apply(diff))\n    evt.preventDefault()\n  }\n\n  function up(evt: PointerEventType): void {\n    const currentLocation = scrollTarget.byDistance(0, false)\n    const targetChanged = currentLocation.index !== index.get()\n    const rawForce = dragTracker.pointerUp(evt) * forceBoost()\n    const force = allowedForce(direction.apply(rawForce), targetChanged)\n    const forceFactor = factorAbs(rawForce, force)\n    const isMoving = deltaAbs(target.get(), dragStartPoint.get()) >= 0.5\n    const isVigorous = targetChanged && forceFactor > 0.75\n    const isBelowThreshold = mathAbs(rawForce) < dragThreshold\n    const speed = isVigorous ? 10 : baseSpeed\n    const mass = isVigorous ? baseMass + 2.5 * forceFactor : baseMass\n\n    if (isMoving && !isMouse) preventClick = true\n    preventScroll = false\n    pointerIsDown = false\n    interactionEvents.removeAll()\n    scrollBody.useSpeed(isBelowThreshold ? 9 : speed).useMass(mass)\n    scrollTo.distance(force, !dragFree)\n    isMouse = false\n    eventHandler.emit('pointerUp')\n  }\n\n  function click(evt: MouseEvent): void {\n    if (preventClick) evt.preventDefault()\n  }\n\n  function clickAllowed(): boolean {\n    return !preventClick\n  }\n\n  function pointerDown(): boolean {\n    return pointerIsDown\n  }\n\n  const self: DragHandlerType = {\n    addActivationEvents,\n    clickAllowed,\n    pointerDown,\n    removeAllEvents,\n  }\n  return self\n}\n","import { AxisOptionType, AxisType } from './Axis'\nimport { mathAbs } from './utils'\n\ntype PointerCoordType = keyof Touch | keyof MouseEvent\nexport type PointerEventType = TouchEvent | MouseEvent\n\nexport type DragTrackerType = {\n  isTouchEvent: (evt: PointerEventType) => evt is TouchEvent\n  pointerDown: (evt: PointerEventType) => number\n  pointerMove: (evt: PointerEventType) => number\n  pointerUp: (evt: PointerEventType) => number\n  readPoint: (evt: PointerEventType, evtAxis?: AxisOptionType) => number\n}\n\nexport function DragTracker(axis: AxisType): DragTrackerType {\n  const logInterval = 170\n\n  let startEvent: PointerEventType\n  let lastEvent: PointerEventType\n\n  function isTouchEvent(evt: PointerEventType): evt is TouchEvent {\n    return typeof TouchEvent !== 'undefined' && evt instanceof TouchEvent\n  }\n\n  function readTime(evt: PointerEventType): number {\n    return evt.timeStamp\n  }\n\n  function readPoint(evt: PointerEventType, evtAxis?: AxisOptionType): number {\n    const property = evtAxis || axis.scroll\n    const coord: PointerCoordType = `client${property === 'x' ? 'X' : 'Y'}`\n    return (isTouchEvent(evt) ? evt.touches[0] : evt)[coord]\n  }\n\n  function pointerDown(evt: PointerEventType): number {\n    startEvent = evt\n    lastEvent = evt\n    return readPoint(evt)\n  }\n\n  function pointerMove(evt: PointerEventType): number {\n    const diff = readPoint(evt) - readPoint(lastEvent)\n    const expired = readTime(evt) - readTime(startEvent) > logInterval\n\n    lastEvent = evt\n    if (expired) startEvent = evt\n    return diff\n  }\n\n  function pointerUp(evt: PointerEventType): number {\n    if (!startEvent || !lastEvent) return 0\n    const diffDrag = readPoint(lastEvent) - readPoint(startEvent)\n    const diffTime = readTime(evt) - readTime(startEvent)\n    const expired = readTime(evt) - readTime(lastEvent) > logInterval\n    const force = diffDrag / diffTime\n    const isFlick = diffTime && !expired && mathAbs(force) > 0.1\n\n    return isFlick ? force : 0\n  }\n\n  const self: DragTrackerType = {\n    isTouchEvent,\n    pointerDown,\n    pointerMove,\n    pointerUp,\n    readPoint,\n  }\n  return self\n}\n","export type PercentOfViewType = {\n  measure: (n: number) => number\n}\n\nexport function PercentOfView(viewSize: number): PercentOfViewType {\n  function measure(n: number): number {\n    return viewSize * (n / 100)\n  }\n\n  const self: PercentOfViewType = {\n    measure,\n  }\n  return self\n}\n","import { map, roundToDecimals, mathSign } from './utils'\nimport { Vector1D, Vector1DType } from './Vector1d'\n\nexport type ScrollBodyType = {\n  direction: () => number\n  seek: (target: Vector1DType) => ScrollBodyType\n  settle: (target: Vector1DType) => boolean\n  update: () => void\n  useBaseMass: () => ScrollBodyType\n  useBaseSpeed: () => ScrollBodyType\n  useMass: (n: number) => ScrollBodyType\n  useSpeed: (n: number) => ScrollBodyType\n}\n\nexport function ScrollBody(\n  location: Vector1DType,\n  baseSpeed: number,\n  baseMass: number,\n): ScrollBodyType {\n  const roundToTwoDecimals = roundToDecimals(2)\n  const velocity = Vector1D(0)\n  const acceleration = Vector1D(0)\n  const attraction = Vector1D(0)\n\n  let attractionDirection = 0\n  let speed = baseSpeed\n  let mass = baseMass\n\n  function update(): void {\n    velocity.add(acceleration)\n    location.add(velocity)\n    acceleration.multiply(0)\n  }\n\n  function applyForce(force: Vector1DType): void {\n    force.divide(mass)\n    acceleration.add(force)\n  }\n\n  function seek(target: Vector1DType): ScrollBodyType {\n    attraction.set(target).subtract(location)\n    const magnitude = map(attraction.get(), 0, 100, 0, speed)\n    attractionDirection = mathSign(attraction.get())\n    attraction.normalize().multiply(magnitude).subtract(velocity)\n    applyForce(attraction)\n    return self\n  }\n\n  function settle(target: Vector1DType): boolean {\n    const diff = target.get() - location.get()\n    const hasSettled = !roundToTwoDecimals(diff)\n    if (hasSettled) location.set(target)\n    return hasSettled\n  }\n\n  function direction(): number {\n    return attractionDirection\n  }\n\n  function useBaseSpeed(): ScrollBodyType {\n    return useSpeed(baseSpeed)\n  }\n\n  function useBaseMass(): ScrollBodyType {\n    return useMass(baseMass)\n  }\n\n  function useSpeed(n: number): ScrollBodyType {\n    speed = n\n    return self\n  }\n\n  function useMass(n: number): ScrollBodyType {\n    mass = n\n    return self\n  }\n\n  const self: ScrollBodyType = {\n    direction,\n    seek,\n    settle,\n    update,\n    useBaseMass,\n    useBaseSpeed,\n    useMass,\n    useSpeed,\n  }\n  return self\n}\n","import { LimitType } from './Limit'\nimport { ScrollBodyType } from './ScrollBody'\nimport { Vector1DType } from './Vector1d'\nimport { mathAbs } from './utils'\nimport { PercentOfViewType } from './PercentOfView'\n\nexport type ScrollBoundsType = {\n  constrain: (pointerDown: boolean) => void\n  toggleActive: (active: boolean) => void\n}\n\nexport function ScrollBounds(\n  limit: LimitType,\n  location: Vector1DType,\n  target: Vector1DType,\n  scrollBody: ScrollBodyType,\n  percentOfView: PercentOfViewType,\n): ScrollBoundsType {\n  const pullBackThreshold = percentOfView.measure(10)\n  const edgeOffsetTolerance = percentOfView.measure(50)\n  const maxFriction = 0.85\n  let disabled = false\n\n  function shouldConstrain(): boolean {\n    if (disabled) return false\n    if (!limit.reachedAny(target.get())) return false\n    if (!limit.reachedAny(location.get())) return false\n    return true\n  }\n\n  function constrain(pointerDown: boolean): void {\n    if (!shouldConstrain()) return\n    const edge = limit.reachedMin(location.get()) ? 'min' : 'max'\n    const diffToEdge = mathAbs(limit[edge] - location.get())\n    const diffToTarget = target.get() - location.get()\n    const friction = Math.min(diffToEdge / edgeOffsetTolerance, maxFriction)\n\n    target.subtract(diffToTarget * friction)\n\n    if (!pointerDown && mathAbs(diffToTarget) < pullBackThreshold) {\n      target.set(limit.constrain(target.get()))\n      scrollBody.useSpeed(10).useMass(3)\n    }\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  const self: ScrollBoundsType = {\n    constrain,\n    toggleActive,\n  }\n  return self\n}\n","import { Limit, LimitType } from './Limit'\nimport { arrayLast } from './utils'\n\nexport type ScrollContainOptionType = '' | 'trimSnaps' | 'keepSnaps'\n\nexport type ScrollContainType = {\n  snapsContained: number[]\n}\n\nexport function ScrollContain(\n  viewSize: number,\n  contentSize: number,\n  snapsAligned: number[],\n  containScroll: ScrollContainOptionType,\n): ScrollContainType {\n  const scrollBounds = Limit(-contentSize + viewSize, snapsAligned[0])\n  const snapsBounded = snapsAligned.map(scrollBounds.constrain)\n  const snapsContained = measureContained()\n\n  function findDuplicates(): LimitType {\n    const startSnap = snapsBounded[0]\n    const endSnap = arrayLast(snapsBounded)\n    const min = snapsBounded.lastIndexOf(startSnap)\n    const max = snapsBounded.indexOf(endSnap) + 1\n    return Limit(min, max)\n  }\n\n  function measureContained(): number[] {\n    if (contentSize <= viewSize) return [scrollBounds.max]\n    if (containScroll === 'keepSnaps') return snapsBounded\n    const { min, max } = findDuplicates()\n    return snapsBounded.slice(min, max)\n  }\n\n  const self: ScrollContainType = {\n    snapsContained,\n  }\n  return self\n}\n","import { Limit, LimitType } from './Limit'\nimport { arrayLast } from './utils'\n\nexport type ScrollLimitType = {\n  limit: LimitType\n}\n\nexport function ScrollLimit(\n  contentSize: number,\n  scrollSnaps: number[],\n  loop: boolean,\n): ScrollLimitType {\n  const limit = measureLimit()\n\n  function measureLimit(): LimitType {\n    const startSnap = scrollSnaps[0]\n    const endSnap = arrayLast(scrollSnaps)\n    const min = loop ? startSnap - contentSize : endSnap\n    const max = startSnap\n    return Limit(min, max)\n  }\n\n  const self: ScrollLimitType = {\n    limit,\n  }\n  return self\n}\n","import { Limit, LimitType } from './Limit'\nimport { Vector1DType } from './Vector1d'\n\nexport type ScrollLooperType = {\n  loop: (direction: number) => void\n}\n\nexport function ScrollLooper(\n  contentSize: number,\n  limit: LimitType,\n  location: Vector1DType,\n  vectors: Vector1DType[],\n): ScrollLooperType {\n  const jointSafety = 0.1\n  const min = limit.min + jointSafety\n  const max = limit.max + jointSafety\n  const { reachedMin, reachedMax } = Limit(min, max)\n\n  function shouldLoop(direction: number): boolean {\n    if (direction === 1) return reachedMax(location.get())\n    if (direction === -1) return reachedMin(location.get())\n    return false\n  }\n\n  function loop(direction: number): void {\n    if (!shouldLoop(direction)) return\n\n    const loopDistance = contentSize * (direction * -1)\n    vectors.forEach((v) => v.add(loopDistance))\n  }\n\n  const self: ScrollLooperType = {\n    loop,\n  }\n  return self\n}\n","import { LimitType } from './Limit'\n\nexport type ScrollProgressType = {\n  get: (n: number) => number\n}\n\nexport function ScrollProgress(limit: LimitType): ScrollProgressType {\n  const { max, length: scrollLength } = limit\n\n  function get(n: number): number {\n    const currentLocation = n - max\n    return currentLocation / -scrollLength\n  }\n\n  const self: ScrollProgressType = {\n    get,\n  }\n  return self\n}\n","import { AlignmentType } from './Alignment'\nimport { AxisType } from './Axis'\nimport { SlidesToScrollType } from './SlidesToScroll'\nimport { arrayLast, arrayLastIndex, mathAbs } from './utils'\n\nexport type ScrollSnapsType = {\n  snaps: number[]\n  snapsAligned: number[]\n}\n\nexport function ScrollSnaps(\n  axis: AxisType,\n  alignment: AlignmentType,\n  containerRect: DOMRect,\n  slideRects: DOMRect[],\n  slideSizesWithGaps: number[],\n  slidesToScroll: SlidesToScrollType,\n  containScroll: boolean,\n): ScrollSnapsType {\n  const { startEdge, endEdge } = axis\n  const { groupSlides } = slidesToScroll\n  const alignments = measureSizes().map(alignment.measure)\n  const snaps = measureUnaligned()\n  const snapsAligned = measureAligned()\n\n  function measureSizes(): number[] {\n    return groupSlides(slideRects)\n      .map((rects) => arrayLast(rects)[endEdge] - rects[0][startEdge])\n      .map(mathAbs)\n  }\n\n  function measureUnaligned(): number[] {\n    return slideRects\n      .map((rect) => containerRect[startEdge] - rect[startEdge])\n      .map((snap) => -mathAbs(snap))\n  }\n\n  function measureAligned(): number[] {\n    const containedStartSnap = 0\n    const containedEndSnap = arrayLast(snaps) - arrayLast(slideSizesWithGaps)\n\n    return groupSlides(snaps)\n      .map((g) => g[0])\n      .map((snap, index, groupedSnaps) => {\n        const isFirst = !index\n        const isLast = index === arrayLastIndex(groupedSnaps)\n        if (containScroll && isFirst) return containedStartSnap\n        if (containScroll && isLast) return containedEndSnap\n        return snap + alignments[index]\n      })\n  }\n\n  const self: ScrollSnapsType = {\n    snaps,\n    snapsAligned,\n  }\n  return self\n}\n","import { LimitType } from './Limit'\nimport { Vector1DType } from './Vector1d'\nimport { mathAbs, mathSign } from './utils'\n\nexport type TargetType = {\n  distance: number\n  index: number\n}\n\nexport type ScrollTargetType = {\n  byIndex: (target: number, direction: number) => TargetType\n  byDistance: (force: number, snap: boolean) => TargetType\n  shortcut: (target: number, direction: number) => number\n}\n\nexport function ScrollTarget(\n  loop: boolean,\n  scrollSnaps: number[],\n  contentSize: number,\n  limit: LimitType,\n  targetVector: Vector1DType,\n): ScrollTargetType {\n  const { reachedAny, removeOffset, constrain } = limit\n\n  function minDistance(distances: number[]): number {\n    return distances.concat().sort((a, b) => mathAbs(a) - mathAbs(b))[0]\n  }\n\n  function findTargetSnap(target: number): TargetType {\n    const distance = loop ? removeOffset(target) : constrain(target)\n    const ascDiffsToSnaps = scrollSnaps\n      .map((scrollSnap) => scrollSnap - distance)\n      .map((diffToSnap) => shortcut(diffToSnap, 0))\n      .map((diff, i) => ({ diff, index: i }))\n      .sort((d1, d2) => mathAbs(d1.diff) - mathAbs(d2.diff))\n\n    const { index } = ascDiffsToSnaps[0]\n    return { index, distance }\n  }\n\n  function shortcut(target: number, direction: number): number {\n    const targets = [target, target + contentSize, target - contentSize]\n\n    if (!loop) return targets[0]\n    if (!direction) return minDistance(targets)\n\n    const matchingTargets = targets.filter((t) => mathSign(t) === direction)\n    return minDistance(matchingTargets)\n  }\n\n  function byIndex(index: number, direction: number): TargetType {\n    const diffToSnap = scrollSnaps[index] - targetVector.get()\n    const distance = shortcut(diffToSnap, direction)\n    return { index, distance }\n  }\n\n  function byDistance(distance: number, snap: boolean): TargetType {\n    const target = targetVector.get() + distance\n    const { index, distance: targetSnapDistance } = findTargetSnap(target)\n    const reachedBound = !loop && reachedAny(target)\n\n    if (!snap || reachedBound) return { index, distance }\n\n    const diffToSnap = scrollSnaps[index] - targetSnapDistance\n    const snapDistance = distance + shortcut(diffToSnap, 0)\n\n    return { index, distance: snapDistance }\n  }\n\n  const self: ScrollTargetType = {\n    byDistance,\n    byIndex,\n    shortcut,\n  }\n  return self\n}\n","import { AnimationType } from './Animation'\nimport { CounterType } from './Counter'\nimport { EventHandlerType } from './EventHandler'\nimport { ScrollTargetType, TargetType } from './ScrollTarget'\nimport { Vector1DType } from './Vector1d'\n\nexport type ScrollToType = {\n  distance: (n: number, snap: boolean) => void\n  index: (n: number, direction: number) => void\n}\n\nexport function ScrollTo(\n  animation: AnimationType,\n  indexCurrent: CounterType,\n  indexPrevious: CounterType,\n  scrollTarget: ScrollTargetType,\n  targetVector: Vector1DType,\n  eventHandler: EventHandlerType,\n): ScrollToType {\n  function scrollTo(target: TargetType): void {\n    const distanceDiff = target.distance\n    const indexDiff = target.index !== indexCurrent.get()\n\n    if (distanceDiff) {\n      animation.start()\n      targetVector.add(distanceDiff)\n    }\n    if (indexDiff) {\n      indexPrevious.set(indexCurrent.get())\n      indexCurrent.set(target.index)\n      eventHandler.emit('select')\n    }\n  }\n\n  function distance(n: number, snap: boolean): void {\n    const target = scrollTarget.byDistance(n, snap)\n    scrollTo(target)\n  }\n\n  function index(n: number, direction: number): void {\n    const targetIndex = indexCurrent.clone().set(n)\n    const target = scrollTarget.byIndex(targetIndex.get(), direction)\n    scrollTo(target)\n  }\n\n  const self: ScrollToType = {\n    distance,\n    index,\n  }\n  return self\n}\n","import { AxisType } from './Axis'\nimport { DirectionType } from './Direction'\nimport { Vector1DType } from './Vector1d'\n\nexport type TranslateType = {\n  clear: () => void\n  to: (vector: Vector1DType) => void\n  toggleActive: (active: boolean) => void\n}\n\nexport function Translate(\n  axis: AxisType,\n  direction: DirectionType,\n  container: HTMLElement,\n): TranslateType {\n  const translate = axis.scroll === 'x' ? x : y\n  const containerStyle = container.style\n  let disabled = false\n\n  function x(n: number): string {\n    return `translate3d(${n}px,0px,0px)`\n  }\n\n  function y(n: number): string {\n    return `translate3d(0px,${n}px,0px)`\n  }\n\n  function to(target: Vector1DType): void {\n    if (disabled) return\n    containerStyle.transform = translate(direction.apply(target.get()))\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  function clear(): void {\n    if (disabled) return\n    containerStyle.transform = ''\n    if (!container.getAttribute('style')) container.removeAttribute('style')\n  }\n\n  const self: TranslateType = {\n    clear,\n    to,\n    toggleActive,\n  }\n  return self\n}\n","import { AxisType } from './Axis'\nimport { arrayKeys } from './utils'\nimport { SlidesInViewType } from './SlidesInView'\nimport { Vector1D, Vector1DType } from './Vector1d'\nimport { Translate, TranslateType } from './Translate'\nimport { DirectionType } from './Direction'\n\ntype EdgeType = 'start' | 'end'\n\ntype LoopPointType = {\n  index: number\n  translate: TranslateType\n  location: Vector1DType\n  target: () => Vector1DType\n}\n\nexport type SlideLooperType = {\n  canLoop: () => boolean\n  clear: () => void\n  loop: () => void\n  loopPoints: LoopPointType[]\n}\n\nexport function SlideLooper(\n  axis: AxisType,\n  direction: DirectionType,\n  viewSize: number,\n  contentSize: number,\n  slideSizesWithGaps: number[],\n  scrollSnaps: number[],\n  slidesInView: SlidesInViewType,\n  scroll: Vector1DType,\n  slides: HTMLElement[],\n): SlideLooperType {\n  const ascItems = arrayKeys(slideSizesWithGaps)\n  const descItems = arrayKeys(slideSizesWithGaps).reverse()\n  const loopPoints = startPoints().concat(endPoints())\n\n  function removeSlideSizes(indexes: number[], from: number): number {\n    return indexes.reduce((a: number, i) => {\n      return a - slideSizesWithGaps[i]\n    }, from)\n  }\n\n  function slidesInGap(indexes: number[], gap: number): number[] {\n    return indexes.reduce((a: number[], i) => {\n      const remainingGap = removeSlideSizes(a, gap)\n      return remainingGap > 0 ? a.concat([i]) : a\n    }, [])\n  }\n\n  function findLoopPoints(indexes: number[], edge: EdgeType): LoopPointType[] {\n    const isStartEdge = edge === 'start'\n    const offset = isStartEdge ? -contentSize : contentSize\n    const slideBounds = slidesInView.findSlideBounds([offset])\n\n    return indexes.map((index) => {\n      const initial = isStartEdge ? 0 : -contentSize\n      const altered = isStartEdge ? contentSize : 0\n      const bounds = slideBounds.filter((b) => b.index === index)[0]\n      const point = bounds[isStartEdge ? 'end' : 'start']\n      const shift = Vector1D(-1)\n      const location = Vector1D(-1)\n      const translate = Translate(axis, direction, slides[index])\n      const target = () => shift.set(scroll.get() > point ? initial : altered)\n      return { index, location, translate, target }\n    })\n  }\n\n  function startPoints(): LoopPointType[] {\n    const gap = scrollSnaps[0] - 1\n    const indexes = slidesInGap(descItems, gap)\n    return findLoopPoints(indexes, 'end')\n  }\n\n  function endPoints(): LoopPointType[] {\n    const gap = viewSize - scrollSnaps[0] - 1\n    const indexes = slidesInGap(ascItems, gap)\n    return findLoopPoints(indexes, 'start')\n  }\n\n  function canLoop(): boolean {\n    return loopPoints.every(({ index }) => {\n      const otherIndexes = ascItems.filter((i) => i !== index)\n      return removeSlideSizes(otherIndexes, viewSize) <= 0.1\n    })\n  }\n\n  function loop(): void {\n    loopPoints.forEach((loopPoint) => {\n      const { target, translate, location } = loopPoint\n      const shift = target()\n      if (shift.get() === location.get()) return\n      if (shift.get() === 0) translate.clear()\n      else translate.to(shift)\n      location.set(shift)\n    })\n  }\n\n  function clear(): void {\n    loopPoints.forEach((loopPoint) => loopPoint.translate.clear())\n  }\n\n  const self: SlideLooperType = {\n    canLoop,\n    clear,\n    loop,\n    loopPoints,\n  }\n  return self\n}\n","import { Limit, LimitType } from './Limit'\n\nexport type SlideBoundType = {\n  start: number\n  end: number\n  index: number\n}\n\nexport type SlidesInViewType = {\n  check: (location: number, bounds?: SlideBoundType[]) => number[]\n  findSlideBounds: (offsets?: number[], threshold?: number) => SlideBoundType[]\n}\n\nexport function SlidesInView(\n  viewSize: number,\n  contentSize: number,\n  slideSizes: number[],\n  snaps: number[],\n  limit: LimitType,\n  loop: boolean,\n  inViewThreshold: number,\n): SlidesInViewType {\n  const { removeOffset, constrain } = limit\n  const roundingSafety = 0.5\n  const cachedOffsets = loop ? [0, contentSize, -contentSize] : [0]\n  const cachedBounds = findSlideBounds(cachedOffsets, inViewThreshold)\n\n  function findSlideThresholds(threshold?: number): number[] {\n    const slideThreshold = threshold || 0\n\n    return slideSizes.map((slideSize) => {\n      const thresholdLimit = Limit(roundingSafety, slideSize - roundingSafety)\n      return thresholdLimit.constrain(slideSize * slideThreshold)\n    })\n  }\n\n  function findSlideBounds(\n    offsets?: number[],\n    threshold?: number,\n  ): SlideBoundType[] {\n    const slideOffsets = offsets || cachedOffsets\n    const slideThresholds = findSlideThresholds(threshold)\n\n    return slideOffsets.reduce((list: SlideBoundType[], offset) => {\n      const bounds = snaps.map((snap, index) => ({\n        start: snap - slideSizes[index] + slideThresholds[index] + offset,\n        end: snap + viewSize - slideThresholds[index] + offset,\n        index,\n      }))\n      return list.concat(bounds)\n    }, [])\n  }\n\n  function check(location: number, bounds?: SlideBoundType[]): number[] {\n    const limitedLocation = loop ? removeOffset(location) : constrain(location)\n    const slideBounds = bounds || cachedBounds\n\n    return slideBounds.reduce((list: number[], slideBound) => {\n      const { index, start, end } = slideBound\n      const inList = list.indexOf(index) !== -1\n      const inView = start < limitedLocation && end > limitedLocation\n      return !inList && inView ? list.concat([index]) : list\n    }, [])\n  }\n\n  const self: SlidesInViewType = {\n    check,\n    findSlideBounds,\n  }\n  return self\n}\n","import { AxisType } from './Axis'\nimport { arrayLast, arrayLastIndex, mathAbs } from './utils'\n\nexport type SlideSizesType = {\n  slideSizes: number[]\n  slideSizesWithGaps: number[]\n}\n\nexport function SlideSizes(\n  axis: AxisType,\n  containerRect: DOMRect,\n  slideRects: DOMRect[],\n  slides: HTMLElement[],\n  includeEdgeGap: boolean,\n): SlideSizesType {\n  const { measureSize, startEdge, endEdge } = axis\n  const startGap = measureStartGap()\n  const endGap = measureEndGap()\n  const slideSizes = slideRects.map(measureSize)\n  const slideSizesWithGaps = measureWithGaps()\n\n  function measureStartGap(): number {\n    if (!includeEdgeGap) return 0\n    const slideRect = slideRects[0]\n    return mathAbs(containerRect[startEdge] - slideRect[startEdge])\n  }\n\n  function measureEndGap(): number {\n    if (!includeEdgeGap) return 0\n    const style = window.getComputedStyle(arrayLast(slides))\n    return parseFloat(style.getPropertyValue(`margin-${endEdge}`))\n  }\n\n  function measureWithGaps(): number[] {\n    return slideRects\n      .map((rect, index, rects) => {\n        const isFirst = !index\n        const isLast = index === arrayLastIndex(rects)\n        if (isFirst) return slideSizes[index] + startGap\n        if (isLast) return slideSizes[index] + endGap\n        return rects[index + 1][startEdge] - rect[startEdge]\n      })\n      .map(mathAbs)\n  }\n\n  const self: SlideSizesType = {\n    slideSizes,\n    slideSizesWithGaps,\n  }\n  return self\n}\n","import { arrayKeys, arrayLast, isNumber } from './utils'\n\nexport type SlidesToScrollOptionType = 'auto' | number\n\nexport type SlidesToScrollType = {\n  groupSlides: <Type>(array: Type[]) => Type[][]\n}\n\nexport function SlidesToScroll(\n  viewSize: number,\n  slideSizesWithGaps: number[],\n  slidesToScroll: SlidesToScrollOptionType,\n): SlidesToScrollType {\n  const groupByNumber = isNumber(slidesToScroll)\n\n  function byNumber<Type>(array: Type[], groupSize: number): Type[][] {\n    return arrayKeys(array)\n      .filter((i) => i % groupSize === 0)\n      .map((i) => array.slice(i, i + groupSize))\n  }\n\n  function bySize<Type>(array: Type[]): Type[][] {\n    return arrayKeys(array)\n      .reduce((groupSizes: number[], i) => {\n        const chunk = slideSizesWithGaps.slice(arrayLast(groupSizes), i + 1)\n        const chunkSize = chunk.reduce((a, s) => a + s, 0)\n        return !i || chunkSize > viewSize ? groupSizes.concat(i) : groupSizes\n      }, [])\n      .map((start, i, groupSizes) => array.slice(start, groupSizes[i + 1]))\n  }\n\n  function groupSlides<Type>(array: Type[]): Type[][] {\n    return groupByNumber ? byNumber(array, slidesToScroll) : bySize(array)\n  }\n\n  const self: SlidesToScrollType = {\n    groupSlides,\n  }\n  return self\n}\n","import { Alignment } from './Alignment'\nimport { Animation, AnimationType } from './Animation'\nimport { Axis, AxisType } from './Axis'\nimport { Counter, CounterType } from './Counter'\nimport { Direction, DirectionType } from './Direction'\nimport { DragHandler, DragHandlerType } from './DragHandler'\nimport { DragTracker } from './DragTracker'\nimport { EventHandlerType } from './EventHandler'\nimport { EventStore, EventStoreType } from './EventStore'\nimport { LimitType } from './Limit'\nimport { OptionsType } from './Options'\nimport { PercentOfView, PercentOfViewType } from './PercentOfView'\nimport { ScrollBody, ScrollBodyType } from './ScrollBody'\nimport { ScrollBounds, ScrollBoundsType } from './ScrollBounds'\nimport { ScrollContain } from './ScrollContain'\nimport { ScrollLimit } from './ScrollLimit'\nimport { ScrollLooper, ScrollLooperType } from './ScrollLooper'\nimport { ScrollProgress, ScrollProgressType } from './ScrollProgress'\nimport { ScrollSnaps } from './ScrollSnaps'\nimport { ScrollTarget, ScrollTargetType } from './ScrollTarget'\nimport { ScrollTo, ScrollToType } from './ScrollTo'\nimport { SlideLooper, SlideLooperType } from './SlideLooper'\nimport { SlidesInView, SlidesInViewType } from './SlidesInView'\nimport { SlideSizes } from './SlideSizes'\nimport { SlidesToScroll, SlidesToScrollType } from './SlidesToScroll'\nimport { Translate, TranslateType } from './Translate'\nimport { arrayKeys, arrayLast, arrayLastIndex } from './utils'\nimport { Vector1D, Vector1DType } from './Vector1d'\n\nexport type EngineType = {\n  axis: AxisType\n  direction: DirectionType\n  animation: AnimationType\n  scrollBounds: ScrollBoundsType\n  scrollLooper: ScrollLooperType\n  scrollProgress: ScrollProgressType\n  index: CounterType\n  indexPrevious: CounterType\n  limit: LimitType\n  location: Vector1DType\n  options: OptionsType\n  percentOfView: PercentOfViewType\n  scrollBody: ScrollBodyType\n  dragHandler: DragHandlerType\n  eventStore: EventStoreType\n  slideLooper: SlideLooperType\n  slidesInView: SlidesInViewType\n  slidesToScroll: SlidesToScrollType\n  target: Vector1DType\n  translate: TranslateType\n  scrollTo: ScrollToType\n  scrollTarget: ScrollTargetType\n  scrollSnaps: number[]\n  slideIndexes: number[]\n  containerRect: DOMRect\n  slideRects: DOMRect[]\n}\n\nexport function Engine(\n  root: HTMLElement,\n  container: HTMLElement,\n  slides: HTMLElement[],\n  options: OptionsType,\n  eventHandler: EventHandlerType,\n): EngineType {\n  // Options\n  const {\n    align,\n    axis: scrollAxis,\n    direction: contentDirection,\n    startIndex,\n    inViewThreshold,\n    loop,\n    speed,\n    dragFree,\n    slidesToScroll: groupSlides,\n    skipSnaps,\n    containScroll,\n  } = options\n\n  // Measurements\n  const containerRect = container.getBoundingClientRect()\n  const slideRects = slides.map((slide) => slide.getBoundingClientRect())\n  const direction = Direction(contentDirection)\n  const axis = Axis(scrollAxis, contentDirection)\n  const viewSize = axis.measureSize(containerRect)\n  const percentOfView = PercentOfView(viewSize)\n  const alignment = Alignment(align, viewSize)\n  const containSnaps = !loop && containScroll !== ''\n  const includeEdgeGap = loop || containScroll !== ''\n  const { slideSizes, slideSizesWithGaps } = SlideSizes(\n    axis,\n    containerRect,\n    slideRects,\n    slides,\n    includeEdgeGap,\n  )\n  const slidesToScroll = SlidesToScroll(\n    viewSize,\n    slideSizesWithGaps,\n    groupSlides,\n  )\n  const { snaps, snapsAligned } = ScrollSnaps(\n    axis,\n    alignment,\n    containerRect,\n    slideRects,\n    slideSizesWithGaps,\n    slidesToScroll,\n    containSnaps,\n  )\n  const contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps)\n  const { snapsContained } = ScrollContain(\n    viewSize,\n    contentSize,\n    snapsAligned,\n    containScroll,\n  )\n  const scrollSnaps = containSnaps ? snapsContained : snapsAligned\n  const { limit } = ScrollLimit(contentSize, scrollSnaps, loop)\n\n  // Indexes\n  const index = Counter(arrayLastIndex(scrollSnaps), startIndex, loop)\n  const indexPrevious = index.clone()\n  const slideIndexes = arrayKeys(slides)\n\n  // Draw\n  const update = (): void => {\n    if (!loop) engine.scrollBounds.constrain(engine.dragHandler.pointerDown())\n    engine.scrollBody.seek(target).update()\n    const settled = engine.scrollBody.settle(target)\n\n    if (settled && !engine.dragHandler.pointerDown()) {\n      engine.animation.stop()\n      eventHandler.emit('settle')\n    }\n    if (!settled) {\n      eventHandler.emit('scroll')\n    }\n    if (loop) {\n      engine.scrollLooper.loop(engine.scrollBody.direction())\n      engine.slideLooper.loop()\n    }\n\n    engine.translate.to(location)\n    engine.animation.proceed()\n  }\n\n  // Shared\n  const animation = Animation(update)\n  const startLocation = scrollSnaps[index.get()]\n  const location = Vector1D(startLocation)\n  const target = Vector1D(startLocation)\n  const scrollBody = ScrollBody(location, speed, 1)\n  const scrollTarget = ScrollTarget(\n    loop,\n    scrollSnaps,\n    contentSize,\n    limit,\n    target,\n  )\n  const scrollTo = ScrollTo(\n    animation,\n    index,\n    indexPrevious,\n    scrollTarget,\n    target,\n    eventHandler,\n  )\n  const slidesInView = SlidesInView(\n    viewSize,\n    contentSize,\n    slideSizes,\n    snaps,\n    limit,\n    loop,\n    inViewThreshold,\n  )\n\n  // DragHandler\n  const dragHandler = DragHandler(\n    axis,\n    direction,\n    root,\n    target,\n    DragTracker(axis),\n    location,\n    animation,\n    scrollTo,\n    scrollBody,\n    scrollTarget,\n    index,\n    eventHandler,\n    percentOfView,\n    loop,\n    dragFree,\n    skipSnaps,\n  )\n\n  // Engine\n  const engine: EngineType = {\n    containerRect,\n    slideRects,\n    animation,\n    axis,\n    direction,\n    dragHandler,\n    eventStore: EventStore(),\n    percentOfView,\n    index,\n    indexPrevious,\n    limit,\n    location,\n    options,\n    scrollBody,\n    scrollBounds: ScrollBounds(\n      limit,\n      location,\n      target,\n      scrollBody,\n      percentOfView,\n    ),\n    scrollLooper: ScrollLooper(contentSize, limit, location, [\n      location,\n      target,\n    ]),\n    scrollProgress: ScrollProgress(limit),\n    scrollSnaps,\n    scrollTarget,\n    scrollTo,\n    slideLooper: SlideLooper(\n      axis,\n      direction,\n      viewSize,\n      contentSize,\n      slideSizesWithGaps,\n      scrollSnaps,\n      slidesInView,\n      location,\n      slides,\n    ),\n    slidesToScroll,\n    slidesInView,\n    slideIndexes,\n    target,\n    translate: Translate(axis, direction, container),\n  }\n  return engine\n}\n","type CallbackType = (evt: EmblaEventType) => void\ntype ListenersType = Partial<{ [key in EmblaEventType]: CallbackType[] }>\n\nexport type EmblaEventType =\n  | 'init'\n  | 'pointerDown'\n  | 'pointerUp'\n  | 'scroll'\n  | 'select'\n  | 'settle'\n  | 'destroy'\n  | 'reInit'\n  | 'resize'\n\nexport type EventHandlerType = {\n  emit: (evt: EmblaEventType) => EventHandlerType\n  on: (evt: EmblaEventType, cb: CallbackType) => EventHandlerType\n  off: (evt: EmblaEventType, cb: CallbackType) => EventHandlerType\n}\n\nexport function EventHandler(): EventHandlerType {\n  const listeners: ListenersType = {}\n\n  function getListeners(evt: EmblaEventType): CallbackType[] {\n    return listeners[evt] || []\n  }\n\n  function emit(evt: EmblaEventType): EventHandlerType {\n    getListeners(evt).forEach((e) => e(evt))\n    return self\n  }\n\n  function on(evt: EmblaEventType, cb: CallbackType): EventHandlerType {\n    listeners[evt] = getListeners(evt).concat([cb])\n    return self\n  }\n\n  function off(evt: EmblaEventType, cb: CallbackType): EventHandlerType {\n    listeners[evt] = getListeners(evt).filter((e) => e !== cb)\n    return self\n  }\n\n  const self: EventHandlerType = {\n    emit,\n    off,\n    on,\n  }\n  return self\n}\n","import { AlignmentOptionType } from './Alignment'\nimport { AxisOptionType } from './Axis'\nimport { SlidesToScrollOptionType } from './SlidesToScroll'\nimport { DirectionOptionType } from './Direction'\nimport { ScrollContainOptionType } from './ScrollContain'\n\nexport type LooseOptionsType = {\n  [key: string]: unknown\n}\n\nexport type CreateOptionsType<Type extends LooseOptionsType> = Type & {\n  active: boolean\n  breakpoints: {\n    [key: string]: Omit<Partial<CreateOptionsType<Type>>, 'breakpoints'>\n  }\n}\n\nexport type OptionsType = CreateOptionsType<{\n  align: AlignmentOptionType\n  axis: AxisOptionType\n  containScroll: ScrollContainOptionType\n  direction: DirectionOptionType\n  slidesToScroll: SlidesToScrollOptionType\n  dragFree: boolean\n  draggable: boolean\n  inViewThreshold: number\n  loop: boolean\n  skipSnaps: boolean\n  speed: number\n  startIndex: number\n}>\n\nexport const defaultOptions: OptionsType = {\n  align: 'center',\n  axis: 'x',\n  containScroll: '',\n  direction: 'ltr',\n  slidesToScroll: 1,\n  breakpoints: {},\n  dragFree: false,\n  draggable: true,\n  inViewThreshold: 0,\n  loop: false,\n  skipSnaps: false,\n  speed: 10,\n  startIndex: 0,\n  active: true,\n}\n\nexport type EmblaOptionsType = Partial<OptionsType>\n","import { LooseOptionsType, CreateOptionsType } from './Options'\nimport { objectKeys, objectsAreEqual, objectsMergeDeep } from './utils'\n\ntype OptionsType = Partial<CreateOptionsType<LooseOptionsType>>\n\nexport type OptionsHandlerType = {\n  merge: <TypeA extends OptionsType, TypeB extends OptionsType>(\n    optionsA: TypeA,\n    optionsB?: TypeB,\n  ) => TypeA\n  areEqual: <TypeA extends OptionsType, TypeB extends OptionsType>(\n    optionsA: TypeA,\n    optionsB: TypeB,\n  ) => boolean\n  atMedia: <Type extends OptionsType>(options: Type) => Type\n}\n\nexport function OptionsHandler(): OptionsHandlerType {\n  function merge<TypeA extends OptionsType, TypeB extends OptionsType>(\n    optionsA: TypeA,\n    optionsB?: TypeB,\n  ): TypeA {\n    return <TypeA>objectsMergeDeep(optionsA, optionsB || {})\n  }\n\n  function areEqual<TypeA extends OptionsType, TypeB extends OptionsType>(\n    optionsA: TypeA,\n    optionsB: TypeB,\n  ): boolean {\n    const breakpointsA = JSON.stringify(objectKeys(optionsA.breakpoints || {}))\n    const breakpointsB = JSON.stringify(objectKeys(optionsB.breakpoints || {}))\n    if (breakpointsA !== breakpointsB) return false\n    return objectsAreEqual(optionsA, optionsB)\n  }\n\n  function atMedia<Type extends OptionsType>(options: Type): Type {\n    const optionsAtMedia = options.breakpoints || {}\n    const matchedMediaOptions = objectKeys(optionsAtMedia)\n      .filter((media) => window.matchMedia(media).matches)\n      .map((media) => optionsAtMedia[media])\n      .reduce((a, mediaOption) => merge(a, mediaOption), {})\n\n    return merge(options, matchedMediaOptions)\n  }\n\n  const self: OptionsHandlerType = {\n    merge,\n    areEqual,\n    atMedia,\n  }\n  return self\n}\n","import { EmblaCarouselType } from '.'\nimport { OptionsHandler } from './OptionsHandler'\nimport { EmblaPluginsType, EmblaPluginType } from './Plugins'\n\ntype PluginChangedHandlerType = () => boolean\n\nexport type PluginsHandlerType = {\n  init: (\n    plugins: EmblaPluginType[],\n    embla: EmblaCarouselType,\n  ) => EmblaPluginsType\n  destroy: () => void\n  haveChanged: PluginChangedHandlerType\n}\n\nexport function PluginsHandler(): PluginsHandlerType {\n  const { atMedia, areEqual } = OptionsHandler()\n  let activePlugins: EmblaPluginType[] = []\n  let pluginsChanged: PluginChangedHandlerType[] = []\n\n  function haveChanged(): boolean {\n    return pluginsChanged.some((hasChanged) => hasChanged())\n  }\n\n  function hasChanged(plugin: EmblaPluginType): PluginChangedHandlerType {\n    const options = atMedia(plugin.options)\n    return (): boolean => !areEqual(options, atMedia(plugin.options))\n  }\n\n  function init(\n    plugins: EmblaPluginType[],\n    embla: EmblaCarouselType,\n  ): EmblaPluginsType {\n    pluginsChanged = plugins.map(hasChanged)\n    activePlugins = plugins.filter((plugin) => atMedia(plugin.options).active)\n    activePlugins.forEach((plugin) => plugin.init(embla))\n\n    return plugins.reduce((map, plugin) => {\n      return Object.assign(map, { [plugin.name]: plugin })\n    }, {})\n  }\n\n  function destroy(): void {\n    activePlugins = activePlugins.filter((plugin) => plugin.destroy())\n  }\n\n  const self: PluginsHandlerType = {\n    init,\n    destroy,\n    haveChanged,\n  }\n  return self\n}\n","import { Engine, EngineType } from './Engine'\nimport { EventStore } from './EventStore'\nimport { EventHandler, EventHandlerType } from './EventHandler'\nimport { defaultOptions, EmblaOptionsType } from './Options'\nimport { OptionsHandler } from './OptionsHandler'\nimport { PluginsHandler } from './PluginsHandler'\nimport { EmblaPluginsType, EmblaPluginType } from './Plugins'\n\nexport type EmblaNodesType = {\n  root: HTMLElement\n  container?: HTMLElement\n  slides?: HTMLElement[]\n}\n\nexport type EmblaCarouselType = {\n  canScrollNext: () => boolean\n  canScrollPrev: () => boolean\n  clickAllowed: () => boolean\n  containerNode: () => HTMLElement\n  internalEngine: () => EngineType\n  destroy: () => void\n  off: EventHandlerType['off']\n  on: EventHandlerType['on']\n  plugins: () => EmblaPluginsType\n  previousScrollSnap: () => number\n  reInit: (options?: EmblaOptionsType, plugins?: EmblaPluginType[]) => void\n  rootNode: () => HTMLElement\n  scrollNext: (jump?: boolean) => void\n  scrollPrev: (jump?: boolean) => void\n  scrollProgress: () => number\n  scrollSnapList: () => number[]\n  scrollTo: (index: number, jump?: boolean) => void\n  selectedScrollSnap: () => number\n  slideNodes: () => HTMLElement[]\n  slidesInView: (target?: boolean) => number[]\n  slidesNotInView: (target?: boolean) => number[]\n}\n\nfunction EmblaCarousel(\n  nodes: HTMLElement | EmblaNodesType,\n  userOptions?: EmblaOptionsType,\n  userPlugins?: EmblaPluginType[],\n): EmblaCarouselType {\n  const resizeHandlers = EventStore()\n  const optionsHandler = OptionsHandler()\n  const pluginsHandler = PluginsHandler()\n  const eventHandler = EventHandler()\n  const { on, off } = eventHandler\n  const reInit = reActivate\n\n  let destroyed = false\n  let engine: EngineType\n  let optionsBase = optionsHandler.merge(\n    defaultOptions,\n    EmblaCarousel.globalOptions,\n  )\n  let options = optionsHandler.merge(optionsBase)\n  let pluginList: EmblaPluginType[] = []\n  let pluginApis: EmblaPluginsType\n  let rootSize = 0\n  let root: HTMLElement\n  let container: HTMLElement\n  let slides: HTMLElement[]\n\n  function storeElements(): void {\n    const providedContainer = 'container' in nodes && nodes.container\n    const providedSlides = 'slides' in nodes && nodes.slides\n\n    root = 'root' in nodes ? nodes.root : nodes\n    container = providedContainer || <HTMLElement>root.children[0]\n    slides = providedSlides || [].slice.call(container.children)\n  }\n\n  function activate(\n    withOptions?: EmblaOptionsType,\n    withPlugins?: EmblaPluginType[],\n  ): void {\n    if (destroyed) return\n    storeElements()\n\n    optionsBase = optionsHandler.merge(optionsBase, withOptions)\n    options = optionsHandler.atMedia(optionsBase)\n    engine = Engine(root, container, slides, options, eventHandler)\n    rootSize = engine.axis.measureSize(root.getBoundingClientRect())\n\n    if (!options.active) return deActivate()\n\n    engine.translate.to(engine.location)\n    pluginList = withPlugins || pluginList\n    pluginApis = pluginsHandler.init(pluginList, self)\n\n    if (options.loop) {\n      if (!engine.slideLooper.canLoop()) {\n        deActivate()\n        return activate({ loop: false }, withPlugins)\n      }\n      engine.slideLooper.loop()\n    }\n    if (options.draggable && container.offsetParent && slides.length) {\n      engine.dragHandler.addActivationEvents()\n    }\n  }\n\n  function reActivate(\n    withOptions?: EmblaOptionsType,\n    withPlugins?: EmblaPluginType[],\n  ): void {\n    const startIndex = selectedScrollSnap()\n    deActivate()\n    activate(optionsHandler.merge({ startIndex }, withOptions), withPlugins)\n    eventHandler.emit('reInit')\n  }\n\n  function deActivate(): void {\n    engine.dragHandler.removeAllEvents()\n    engine.animation.stop()\n    engine.eventStore.removeAll()\n    engine.translate.clear()\n    engine.slideLooper.clear()\n    pluginsHandler.destroy()\n  }\n\n  function destroy(): void {\n    if (destroyed) return\n    destroyed = true\n    resizeHandlers.removeAll()\n    deActivate()\n    eventHandler.emit('destroy')\n  }\n\n  function resize(): void {\n    const newOptions = optionsHandler.atMedia(optionsBase)\n    const optionsChanged = !optionsHandler.areEqual(newOptions, options)\n    const newRootSize = engine.axis.measureSize(root.getBoundingClientRect())\n    const rootSizeChanged = rootSize !== newRootSize\n    const pluginsChanged = pluginsHandler.haveChanged()\n\n    if (rootSizeChanged || optionsChanged || pluginsChanged) reActivate()\n    eventHandler.emit('resize')\n  }\n\n  function slidesInView(target?: boolean): number[] {\n    const location = engine[target ? 'target' : 'location'].get()\n    const type = options.loop ? 'removeOffset' : 'constrain'\n    return engine.slidesInView.check(engine.limit[type](location))\n  }\n\n  function slidesNotInView(target?: boolean): number[] {\n    const inView = slidesInView(target)\n    return engine.slideIndexes.filter((index) => inView.indexOf(index) === -1)\n  }\n\n  function scrollTo(index: number, jump?: boolean, direction?: number): void {\n    if (!options.active || destroyed) return\n    engine.scrollBody.useBaseMass().useSpeed(jump ? 100 : options.speed)\n    engine.scrollTo.index(index, direction || 0)\n  }\n\n  function scrollNext(jump?: boolean): void {\n    const next = engine.index.clone().add(1)\n    scrollTo(next.get(), jump === true, -1)\n  }\n\n  function scrollPrev(jump?: boolean): void {\n    const prev = engine.index.clone().add(-1)\n    scrollTo(prev.get(), jump === true, 1)\n  }\n\n  function canScrollNext(): boolean {\n    const next = engine.index.clone().add(1)\n    return next.get() !== selectedScrollSnap()\n  }\n\n  function canScrollPrev(): boolean {\n    const prev = engine.index.clone().add(-1)\n    return prev.get() !== selectedScrollSnap()\n  }\n\n  function scrollSnapList(): number[] {\n    return engine.scrollSnaps.map(engine.scrollProgress.get)\n  }\n\n  function scrollProgress(): number {\n    return engine.scrollProgress.get(engine.location.get())\n  }\n\n  function selectedScrollSnap(): number {\n    return engine.index.get()\n  }\n\n  function previousScrollSnap(): number {\n    return engine.indexPrevious.get()\n  }\n\n  function clickAllowed(): boolean {\n    return engine.dragHandler.clickAllowed()\n  }\n\n  function plugins(): EmblaPluginsType {\n    return pluginApis\n  }\n\n  function internalEngine(): EngineType {\n    return engine\n  }\n\n  function rootNode(): HTMLElement {\n    return root\n  }\n\n  function containerNode(): HTMLElement {\n    return container\n  }\n\n  function slideNodes(): HTMLElement[] {\n    return slides\n  }\n\n  const self: EmblaCarouselType = {\n    canScrollNext,\n    canScrollPrev,\n    clickAllowed,\n    containerNode,\n    internalEngine,\n    destroy,\n    off,\n    on,\n    plugins,\n    previousScrollSnap,\n    reInit,\n    rootNode,\n    scrollNext,\n    scrollPrev,\n    scrollProgress,\n    scrollSnapList,\n    scrollTo,\n    selectedScrollSnap,\n    slideNodes,\n    slidesInView,\n    slidesNotInView,\n  }\n\n  activate(userOptions, userPlugins)\n  resizeHandlers.add(window, 'resize', resize)\n  setTimeout(() => eventHandler.emit('init'), 0)\n  return self\n}\n\nEmblaCarousel.globalOptions = <EmblaOptionsType | undefined>undefined\nEmblaCarousel.optionsHandler = OptionsHandler\n\nexport default EmblaCarousel\n"]},"metadata":{},"sourceType":"module"}